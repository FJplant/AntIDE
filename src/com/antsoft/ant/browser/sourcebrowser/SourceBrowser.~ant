/*
 * Ant ( JDK wrapper Java IDE )
 * Version 1.0
 * Copyright (c) 1998-1999 Antsoft Co.
 * All rights reserved.
 *  This program and source file is protected by Korea and international
 * Copyright laws.
 *
 * $Header: /AntIDE/source/ant/browser/sourcebrowser/SourceBrowser.java 31    99-05-29 6:28p Remember $
 * $Revision: 31 $
 * $History: SourceBrowser.java $
 * 
 * *****************  Version 31  *****************
 * User: Remember     Date: 99-05-29   Time: 6:28p
 * Updated in $/AntIDE/source/ant/browser/sourcebrowser
 * 
 * *****************  Version 30  *****************
 * User: Remember     Date: 99-05-28   Time: 12:03p
 * Updated in $/AntIDE/source/ant/browser/sourcebrowser
 * 
 * *****************  Version 29  *****************
 * User: Remember     Date: 99-05-27   Time: 5:48p
 * Updated in $/AntIDE/source/ant/browser/sourcebrowser
 * 
 * *****************  Version 28  *****************
 * User: Remember     Date: 99-05-25   Time: 2:28a
 * Updated in $/AntIDE/source/ant/browser/sourcebrowser
 *
 */
package com.antsoft.ant.browser.sourcebrowser;

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.util.Vector;

import com.antsoft.ant.manager.projectmanager.*;
import com.antsoft.ant.util.BorderList;

/**
 *  class SourceBrowser
 *
 *  @author Jinwoo Baek
 *  @author kim sang kyun
 */
public class SourceBrowser extends JPanel implements ActionListener {
	/** Tree형태로 분석된 소스를 보여준다. */
	private JTree tree = null;

	/** Project Explorer에 Embed 된다. */
	private ProjectExplorer pe = null;

	/** tree's root node */
	protected DefaultMutableTreeNode rootNode;

	/** manager tree model */
	protected DefaultTreeModel treeModel;

	/** tree selection model */
	private TreeSelectionModel treeSelectionModel;

  private JComboBox combo;
  private DefaultComboBoxModel comboM;

	/** TreeCell Renderer */
	private SourceBrowserTreeCellRenderer renderer = new SourceBrowserTreeCellRenderer();

	private Vector nodeList = new Vector();

  /** 현재 보여줄 클래스 노드 */
  private DefaultMutableTreeNode currentClass = null;
  private DefaultMutableTreeNode currentNode = null;

	/** scroller */
	private JScrollPane scrollPane = null;
	private JViewport vp = null;

  /** Popup mene */
  private Icon addfieldIcon = new ImageIcon(getClass().getResource("image/addfield.gif"));
  private Icon addmethodIcon = new ImageIcon(getClass().getResource("image/addmethod.gif"));
  private Icon addgetsetIcon = new ImageIcon(getClass().getResource("image/addgetset.gif"));
  private Icon addmainIcon = new ImageIcon(getClass().getResource("image/addmain.gif"));
  private Icon addeventIcon = new ImageIcon(getClass().getResource("image/addevent.gif"));

  private JPopupMenu classPopup = new JPopupMenu();
  private JMenuItem addField = new JMenuItem("Add Field", addfieldIcon);
  private JMenuItem addMain = new JMenuItem("Add Main Method", addmainIcon);
  private JMenuItem addMethod = new JMenuItem("Add Method", addmethodIcon);
  private JMenuItem addGetSet= new JMenuItem("Add GetSet Method", addgetsetIcon);
  private JMenuItem addHandler = new JMenuItem("Add EventHandler", addeventIcon);

  private JLabel sourceNameLbl = new JLabel("     ");

  private JButton addFieldBtn, addMainBtn, addMethodBtn, addGetSetBtn, addHandlerBtn;

	/**
	 *  현 객체의 레퍼런스를 받는다.
	 */
	public SourceBrowser SourceBrowser() {
		return this;
	}

  public void setSelLineBorder(){
    setBorder(BorderList.selLineBorder);
  }

  public void clearBorder(){
    setBorder(BorderList.unselLineBorder);
  }

  private void enableBtns(boolean flag){
    addFieldBtn.setEnabled(flag);
    addMainBtn.setEnabled(flag);
    addMethodBtn.setEnabled(flag);
    addGetSetBtn.setEnabled(flag);
    addHandlerBtn.setEnabled(flag);
  }

	/**
	 * Constructor
	 */
	public SourceBrowser(ProjectExplorer pe) {

		this.pe = pe;
		this.setPreferredSize(new Dimension(250, 0));
		this.setMaximumSize(new Dimension(2000, 0));
		this.setMinimumSize(new Dimension(0, 0));
		this.setLayout(new BorderLayout());
    setBorder(BorderList.unselLineBorder);

    comboM = new DefaultComboBoxModel();
    combo = new JComboBox(comboM);
    combo.setToolTipText("Selected Class");
    final ProjectExplorer pe_final = pe;
    combo.addItemListener(new ItemListener(){
      public void itemStateChanged(ItemEvent e){
        if(comboM.getSelectedItem() == null) return;

        String selClass = comboM.getSelectedItem().toString();
        for(int i=0; i<rootNode.getChildCount(); i++){
          DefaultMutableTreeNode child = (DefaultMutableTreeNode)rootNode.getChildAt(i);
          if(child.toString().equals(comboM.getSelectedItem())){
            tree.setSelectionPath(new TreePath(child.getPath()));
  					pe_final.sourceBrowserSelection(null, child.toString());
            break;
          }
        }
      }
    });

    addFieldBtn = new JButton(addfieldIcon);
    addFieldBtn.setMargin(new Insets(0,0,0,0));
    addFieldBtn.setActionCommand("ADD_FIELD_B");
    addFieldBtn.addActionListener(this);
    addFieldBtn.setToolTipText("Add Field");

    addMainBtn = new JButton(addmainIcon);
    addMainBtn.setMargin(new Insets(0,0,0,0));
    addMainBtn.setActionCommand("ADD_MAIN_B");
    addMainBtn.addActionListener(this);
    addMainBtn.setToolTipText("Add Main Method");

    addMethodBtn = new JButton(addmethodIcon);
    addMethodBtn.setMargin(new Insets(0,0,0,0));
    addMethodBtn.setActionCommand("ADD_METHOD_B");
    addMethodBtn.addActionListener(this);
    addMethodBtn.setToolTipText("Add Method");

    addGetSetBtn = new JButton(addgetsetIcon);
    addGetSetBtn.setMargin(new Insets(0,0,0,0));
    addGetSetBtn.setActionCommand("ADD_GETSET_B");
    addGetSetBtn.addActionListener(this);
    addGetSetBtn.setToolTipText("Add Getter, Setter Method");

    addHandlerBtn = new JButton(addeventIcon);
    addHandlerBtn.setMargin(new Insets(0,0,0,0));
    addHandlerBtn.setActionCommand("ADD_HANDLER_B");
    addHandlerBtn.addActionListener(this);
    addHandlerBtn.setToolTipText("Add Event Handler Inner Class");

    Box btnBox = Box.createHorizontalBox();
    btnBox.add(addFieldBtn);
    btnBox.add(addMainBtn);
    btnBox.add(addMethodBtn);
    btnBox.add(addGetSetBtn);
    btnBox.add(addHandlerBtn);     

    JPanel btnBoxP = new JPanel(new FlowLayout(FlowLayout.RIGHT));
    btnBoxP.add(btnBox);

    enableBtns(false);

    JPanel topP = new JPanel(new BorderLayout(2, 0));
    topP.add(combo, BorderLayout.WEST);
    topP.add(btnBoxP, BorderLayout.CENTER);

    add(topP, BorderLayout.NORTH);
		rootNode = new DefaultMutableTreeNode(
                        new SourceBrowserTreeEntry("", SourceBrowserTreeEntry.FILEROOTNODE));
		treeModel = new DefaultTreeModel(rootNode);
		tree = new JTree(treeModel);
    tree.setDoubleBuffered(true);
    tree.putClientProperty("JTree.lineStyle", "Angled");
		tree.setEditable(false);
		treeSelectionModel = tree.getSelectionModel();
		treeSelectionModel.setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setCellRenderer(renderer);

		// tree에서 item을 선택하면 소스에 적당한 위치로 이동하도록 하는 것이 좋겠쥐?
    tree.addMouseListener(new TreeMouseEventHandler());
    // Java File Name인 루트를 안보이게 하려면 아래를 Uncomment
    tree.setRootVisible( false );
    tree.setShowsRootHandles( true );

		scrollPane = new JScrollPane(tree);
		vp = scrollPane.getViewport();
		this.add(scrollPane, BorderLayout.CENTER);
    tree.addMouseMotionListener( new MouseMotionHandler() );

    tree.addMouseListener(new MouseAdapter() {

      public void mouseClicked(MouseEvent evt) {
        remindPE();
        if (evt.getModifiers() == InputEvent.BUTTON3_MASK) {
          tree.setSelectionPath(tree.getPathForLocation(evt.getX(), evt.getY()));
          TreePath path = tree.getSelectionPath();

					if (path != null) {
          	DefaultMutableTreeNode dmtn = (DefaultMutableTreeNode)path.getLastPathComponent();
            Object obj = dmtn.getUserObject();
						if (obj instanceof SourceBrowserTreeEntry) {
							SourceBrowserTreeEntry sbte = (SourceBrowserTreeEntry)obj;
              if (sbte.getType() == SourceBrowserTreeEntry.CLASSNODE) {
              	classPopup.show(tree, evt.getX(), evt.getY());
              }
						}
        	}
				}
      }
    });
    addField.setActionCommand("ADD_FIELD");
    addField.addActionListener(this);
    addMain.setActionCommand("ADD_MAIN");
    addMain.addActionListener(this);
    addMethod.setActionCommand("ADD_METHOD");
    addMethod.addActionListener(this);
    addGetSet.setActionCommand("ADD_GETSET");
    addGetSet.addActionListener(this);
    addHandler.setActionCommand("ADD_HANDLER");
    addHandler.addActionListener(this);
    classPopup.add(addField);
    classPopup.add(addMain);
    classPopup.add(addMethod);
    classPopup.add(addGetSet);
    classPopup.add(addHandler);
	}

  private void remindPE(){
    pe.setFocusedComponent(ProjectExplorer.SOURCE_BROWSER);
  }

  //tree의 왼쪽 위가 보이도록 한다
  public void setPositionToLeftTop(){
    vp.setViewPosition(new Point(0, 0));
  }

  public void actionPerformed(ActionEvent evt) {
    String cmd = evt.getActionCommand();

    if (cmd.equals("ADD_FIELD"))  {
    	if ((pe != null) && (currentNode != null)) {
      	pe.addField(currentNode.toString());
      }
    }

    else if (cmd.equals("ADD_MAIN"))  {
    	if ((pe != null) && (currentNode != null)) {
      	pe.addMain(currentNode.toString());
      }
    }

    else if (cmd.equals("ADD_METHOD"))  {
    	if ((pe != null) && (currentNode != null)) {
      	pe.addMethod(currentNode.toString());
      }
    }

    else if (cmd.equals("ADD_GETSET"))  {
    	if ((pe != null) && (currentNode != null)) {
      	pe.addGetSetMethod(tree, currentNode);
      }
    }

  	else if (cmd.equals("ADD_HANDLER"))  {
    	if ((pe != null) && (currentNode != null)) {
      	pe.addHandler(currentNode.toString());
      }
    }

    else if (cmd.equals("ADD_FIELD_B"))  {
    	if (comboM.getSelectedItem() != null) {
      	pe.addField(comboM.getSelectedItem().toString());
      }
    }

    else if (cmd.equals("ADD_MAIN_B"))  {
    	if (comboM.getSelectedItem() != null) {
      	pe.addMain(comboM.getSelectedItem().toString());
      }
    }

    else if (cmd.equals("ADD_METHOD_B"))  {
    	if (comboM.getSelectedItem() != null) {
      	pe.addMethod(comboM.getSelectedItem().toString());
      }
    }

    else if (cmd.equals("ADD_GETSET_B"))  {
    	if (comboM.getSelectedItem() != null) {
        for(int i=0; i<rootNode.getChildCount(); i++){
          DefaultMutableTreeNode child = (DefaultMutableTreeNode)rootNode.getChildAt(i);
          if(child.toString().equals(comboM.getSelectedItem())){
            pe.addGetSetMethod(tree, child);
            break;
          }
        }
      }
    }

  	else if (cmd.equals("ADD_HANDLER_B"))  {
    	if (comboM.getSelectedItem() != null) {
      	pe.addHandler(comboM.getSelectedItem().toString());
      }
    }
  }

	/**
	 *  package 를 나타내는 node를 추가한다.
	 *
	 *  @param packageNode 추가할 노드
	 */
	public DefaultMutableTreeNode addPackageNode(String packageNode) {
		if ((packageNode != null) && (!packageNode.equals(""))) {
			SourceBrowserTreeEntry sbte = new SourceBrowserTreeEntry(packageNode,
																		SourceBrowserTreeEntry.PACKAGENODE);
			nodeList.addElement(sbte);
			return addObject(rootNode, sbte, true);
		}
		return null;
	}

	/**
	 *  class 를 나타내는 node를 추가한다.
	 *
	 *  @param classNode 추가할 노드
	 */
	public DefaultMutableTreeNode addClassNode(String classNode) {
		if ((classNode != null) && (!classNode.equals(""))) {

    if(comboM.getIndexOf(classNode) == -1) comboM.addElement(classNode);

			SourceBrowserTreeEntry sbte = new SourceBrowserTreeEntry(classNode,
																		SourceBrowserTreeEntry.CLASSNODE);
            // 새로운 클래스가 들어왔을 경우 현재 클래스를 설정한다.
            currentClass = addObject(rootNode, sbte, true);
            return currentClass;
		}
		return null;
	}

	/**
	 *  interface 를 나타내는 node를 추가한다.
	 *
	 *  @param interfaceNode 추가할 노드
	 */
	public DefaultMutableTreeNode addInterfaceNode(String interfaceNode) {
		if ((interfaceNode != null) && (!interfaceNode.equals(""))) {
			SourceBrowserTreeEntry sbte = new SourceBrowserTreeEntry(interfaceNode,
																		SourceBrowserTreeEntry.INTERFACENODE);
            // 새로운 클래스가 들어왔을 경우 현재 클래스를 설정한다.
            currentClass = addObject(rootNode, sbte, true);
            return currentClass;
		}
		return null;
	}

	/**
	 *  attribute 를 나타내는 node를 추가한다.
	 *
	 *  @param attNode 추가할 노드
	 */
	public DefaultMutableTreeNode addAttributeNode(String attNode) {
		if ((attNode != null) && (!attNode.equals(""))) {
			SourceBrowserTreeEntry sbte = new SourceBrowserTreeEntry(attNode,
																		SourceBrowserTreeEntry.FIELDNODE);
            if (currentClass != null) return addObject(currentClass, sbte, true);
			else return addObject(rootNode, sbte, true);
		}
		return null;
	}

	/**
	 *  operation 을 나타내는 node를 추가한다.
	 *
	 *  @param operNode 추가할 노드
	 */
	public DefaultMutableTreeNode addOperationNode(String operNode) {
		if ((operNode != null) && (!operNode.equals(""))) {
			SourceBrowserTreeEntry sbte = new SourceBrowserTreeEntry(operNode,
																		SourceBrowserTreeEntry.METHODNODE);
			if (currentClass != null) return addObject(currentClass, sbte, true);
            else return addObject(rootNode, sbte, true);
		}
		return null;
	}

	/**
	 *  inner class 를 나타내는 node를 추가한다.
	 *
	 *  @param innerNode 추가할 노드
	 */
	public DefaultMutableTreeNode addInnerClassNode(String innerNode) {
		if ((innerNode != null) && (!innerNode.equals(""))) {
			SourceBrowserTreeEntry sbte = new SourceBrowserTreeEntry(innerNode,
																		SourceBrowserTreeEntry.INNERCLASSNODE);
            if (currentClass != null) return addObject(currentClass, sbte, true);
			else return addObject(rootNode, sbte, true);
		}
		return null;
	}

	/**
	 *  import 를 나타내는 node를 추가한다.
	 *
	 *  @param importNode 추가할 노드
	 */
	public DefaultMutableTreeNode addImportNode(String importNode) {
		if ((importNode != null) && (!importNode.equals(""))) {
			SourceBrowserTreeEntry sbte = new SourceBrowserTreeEntry(importNode,
																		SourceBrowserTreeEntry.LIBNODE);
			return addObject(rootNode, sbte, true);
		}
		return null;
	}

	/**
	 *  Tree 에 노드를 추가한다.
	 *
	 *  @param parent 부모 노드
	 *  @param child 추가할 노드 객체
	 *  @param shouldBeVisible 보여져야 하는가?
	 */
	public DefaultMutableTreeNode addObject(DefaultMutableTreeNode parent, Object child,
                                                boolean shouldBeVisible) {
		DefaultMutableTreeNode childNode = new DefaultMutableTreeNode(child);

		if (parent == null) parent = rootNode;

		// 노드의 제 위치(Sorting이 되게)를 찾아서 넣어야한다. -_-;;
		int index = 0;
        boolean same = false;
        SourceBrowserTreeEntry sbte = (SourceBrowserTreeEntry)child;
        // root
        if (parent == rootNode) {
            for (int i = 0; i < parent.getChildCount(); i++) {
                boolean stop = false;
                SourceBrowserTreeEntry iter =
                        (SourceBrowserTreeEntry)((DefaultMutableTreeNode)parent.getChildAt(i)).getUserObject();
                switch (sbte.getType()) {
                case SourceBrowserTreeEntry.INTERFACENODE:
                	if (iter.getType() == SourceBrowserTreeEntry.INTERFACENODE) {
                  	if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) > 0) index++;
                    else if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) == 0) {
                    	stop = true;
                      same = true;
                    }
                    else {
                    	stop = true;
                      currentClass = childNode;
                    }
                  }
                  else stop = true;
                  break;
                case SourceBrowserTreeEntry.CLASSNODE:
                	if (iter.getType() == SourceBrowserTreeEntry.INTERFACENODE) index++;
                  else if (iter.getType() == SourceBrowserTreeEntry.CLASSNODE) {
                  	if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) > 0) index++;
                    else if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) == 0) {
                      stop = true;
                      same = true;
                    }
                    else {
                      stop = true;
                      currentClass = childNode;
                    }
                  }
                  else stop = true;

                  break;
                case SourceBrowserTreeEntry.PACKAGENODE:
                	if (iter.getType() == SourceBrowserTreeEntry.INTERFACENODE) index++;
                  else if (iter.getType() == SourceBrowserTreeEntry.CLASSNODE) index++;
                  else if (iter.getType() == SourceBrowserTreeEntry.PACKAGENODE) {
	                  if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) > 0) index++;
                    else if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) == 0) {
                      stop = true;
                      same = true;
                    }
                    else stop = true;
                  }
                  else stop = true;
                  break;
                case SourceBrowserTreeEntry.LIBNODE:
                	if (iter.getType() == SourceBrowserTreeEntry.INTERFACENODE) index++;
                  else if (iter.getType() == SourceBrowserTreeEntry.CLASSNODE) index++;
                  else if (iter.getType() == SourceBrowserTreeEntry.PACKAGENODE) index++;
                  else if (iter.getType() == SourceBrowserTreeEntry.LIBNODE) {
                    if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) > 0) index++;
                    else if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) == 0) {
                      stop = true;
                      same = true;
										}
                    else stop = true;
                  }
                  else stop = true;
                	break;
                }
                if (stop) break;
            	}
        		}
        		else {
            	for (int i = 0; i < parent.getChildCount(); i++) {
                boolean stop = false;
                SourceBrowserTreeEntry iter =
                        (SourceBrowserTreeEntry)((DefaultMutableTreeNode)parent.getChildAt(i)).getUserObject();
                switch (sbte.getType()) {
                case SourceBrowserTreeEntry.INNERCLASSNODE:
                    if (iter.getType() == SourceBrowserTreeEntry.INNERCLASSNODE) {
                    if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) > 0) index++;
                    else if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) == 0) {
                      stop = true;
                      same = true;
                    }
                    else stop = true;
                  }
                  else stop = true;
                  break;
                case SourceBrowserTreeEntry.FIELDNODE:
                    if (iter.getType() == SourceBrowserTreeEntry.INNERCLASSNODE) index++;
	                  else if (iter.getType() == SourceBrowserTreeEntry.METHODNODE) index++;
                    else if (iter.getType() == SourceBrowserTreeEntry.FIELDNODE) {
                    if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) > 0) index++;
                    else if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) == 0) {
                        stop = true;
                      same = true;
                    }
                    else stop = true;
                  }
                  else stop = true;
                    break;
                case SourceBrowserTreeEntry.METHODNODE:
                    if (iter.getType() == SourceBrowserTreeEntry.INNERCLASSNODE) index++;
//                  else if (iter.getType() == SourceBrowserTreeEntry.FIELDNODE) index++;
                  else if (iter.getType() == SourceBrowserTreeEntry.METHODNODE) {
                    if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) > 0) index++;
                    else if (sbte.getContent().toLowerCase().compareTo(iter.getContent().toLowerCase()) == 0) {
                        stop = true;
                      same = true;
                    }
                    else stop = true;
                  }
                  else stop = true;
                    break;
                }
                if (stop) break;
            }
        }
		if (!same) treeModel.insertNodeInto(childNode, parent, index);

		// Make sure the user can see the lovely new node.
		if (shouldBeVisible) {
			tree.expandPath(new TreePath(parent.getPath()));
		}
		return childNode;
	}

	public void initViewport() {
		vp.setViewPosition(new Point(0, 0));
	}

	/**
	 *  Tree에서 노드를 삭제한다.
	 *
	 *  @param item 삭제할 item
	 */
	public void removeNode(String node, int type) {
  	SourceBrowserTreeEntry entry = new SourceBrowserTreeEntry(node, type);
		for (int i = 0; i < tree.getRowCount(); i++) {
			TreePath tp = tree.getPathForRow(i);
			DefaultMutableTreeNode tn = (DefaultMutableTreeNode)tp.getLastPathComponent();
			Object obj = tn.getUserObject();
			if (obj instanceof SourceBrowserTreeEntry) {
				SourceBrowserTreeEntry sbte = (SourceBrowserTreeEntry)obj;
				if (sbte.equals(entry)) {
          treeModel.removeNodeFromParent(tn);
          if(entry.getType() == SourceBrowserTreeEntry.CLASSNODE){
            comboM.removeElement(node);
          }
					break;
				}
			}
		}
  }

  /**
   * reload
   */
  public void reload(){
    int width = getSize().width;
    int btnWidth = addFieldBtn.getWidth() * 5;
    combo.setPreferredSize(new Dimension(width - btnWidth - 12, combo.getHeight()));

    enableBtns(true);
  }

  public void clear(){
    removeAll();
    if(comboM.getSize() > 0)  comboM.removeAllElements();
    enableBtns(false);
  }

	/**
	 *  Tree에서 모든 노드를 삭제한다.
	 */
	public void removeAll() {
    if(rootNode.getChildCount() > 0){
  		rootNode.removeAllChildren();
	  	treeModel.reload();
    }
	}

  class TreeMouseEventHandler extends MouseAdapter {
    public void mousePressed(MouseEvent evt){

      if(tree.isSelectionEmpty()) return;
      if(tree.hasFocus()){
        TreePath tp = tree.getSelectionPath();
        currentNode = (DefaultMutableTreeNode)tp.getLastPathComponent();
        if (!currentNode.isRoot()) {
          // 상위의 class name과 함께 보낸다.
          DefaultMutableTreeNode parent = (DefaultMutableTreeNode)currentNode.getParent();
          String parentContent = null;
          if (parent != null && !parent.isRoot()) {
            SourceBrowserTreeEntry p = (SourceBrowserTreeEntry)parent.getUserObject();
            parentContent = p.getContent();
          }
          SourceBrowserTreeEntry sbte = (SourceBrowserTreeEntry)currentNode.getUserObject();
          pe.sourceBrowserSelection(parentContent,sbte.getContent());

          if(comboM.getIndexOf(sbte.toString()) != -1) comboM.setSelectedItem(sbte.toString());
        }
      }
    }
  }


	/**
	 * Source Browser내에서 화면 폭 때문에 보이지 않는 멤버들을 보여주기 위해서 툴팁을
	 * 이용한다.
	 * 좀더 세련되게 보이기 위해서는 원래의 위치에 덮어 쓰는 것이 좋을 것이다.
	 */
	class MouseMotionHandler extends MouseMotionAdapter {
		public void mouseMoved( MouseEvent e ) {
			TreePath path = tree.getClosestPathForLocation( e.getX(), e.getY() );
			if ( path != null ) {
				DefaultMutableTreeNode tn = (DefaultMutableTreeNode)path.getLastPathComponent();
				Object obj = tn.getUserObject();
				if (obj instanceof SourceBrowserTreeEntry) {
					SourceBrowserTreeEntry sbte = (SourceBrowserTreeEntry)obj;
					tree.setToolTipText( sbte.getContent() );
				}
			} else
				tree.setToolTipText( "" );
		}
	}
}
