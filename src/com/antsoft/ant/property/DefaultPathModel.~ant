/*
 * $Header: /AntIDE/source/ant/property/DefaultPathModel.java 11    99-06-01 11:55a Itree $
 * Ant ( JDK wrapper Java IDE )
 * Version 1.0
 * Copyright (c) 1998-1999 Antsoft Co. All rights reserved.
 *  This program and source file is protected by Korea and international
 * Copyright laws.
 *
 * $Revision: 11 $
 */
package com.antsoft.ant.property;

import com.antsoft.ant.pool.librarypool.*;
import com.antsoft.ant.util.FileClassLoader;
import java.util.Vector;
import java.io.*;
import java.util.Enumeration;

/**
 * DefaultPath Model Implemention class
 *
 * @author kim sang kyun
 */
public class DefaultPathModel implements Serializable, Cloneable{

  private JdkInfoContainer jdkInfos = new JdkInfoContainer();
  private LibInfoContainer allLibInfos = new LibInfoContainer();
  private LibInfoContainer selectedLibInfos = new LibInfoContainer();
  private JdkInfo currentJdkInfo = null;
  private String sourceRoot=null;
  private String outputRoot=null;
  private String documentRoot=null;
  private FileClassLoader loader = null;
  private String classPath = null;


  public String toString(){
    StringBuffer buf = new StringBuffer();
    int i=0;

    if(allLibInfos != null){
      for(i=0; i<allLibInfos.getSize(); i++){
        LibInfo obj = (LibInfo)allLibInfos.getLibraryInfo(i);
        buf.append("PM_AllLib_Infos=" + "1"+obj.getName() + "#" +
                                     "2"+obj.getSourcePath() + "#" +
                                     "3"+obj.getDocPath() + "#" +
                                     "4"+obj.getClassPathString() + "\r\n");
      }
    }

    if(jdkInfos != null){
      for(i=0; i<jdkInfos.getSize(); i++){
        JdkInfo obj = jdkInfos.getJdkInfo(i);
        buf.append("PM_JDK_Infos=" + "1"+obj.getJavaEXEPath() + "#" +
                                  "2"+obj.getJavacEXEPath() + "#" +
                                  "3"+obj.getAppletviewerEXEPath() + "#" +
                                  "4"+obj.getSourcePath() + "#" +
                                  "5"+obj.getDocPath() + "#" +
                                  "6"+obj.getVersion() + "#" +
                                  "7"+obj.getClassPathString() + "\r\n");
      }
    }

    if(selectedLibInfos != null){
      for(i=0; i<selectedLibInfos.getSize(); i++){
        LibInfo obj = (LibInfo)selectedLibInfos.getLibraryInfo(i);
        buf.append("PM_Selected_Lib_Infos=" + "1"+obj.getName() + "#" +
                                           "2"+obj.getSourcePath() + "#" +
                                           "3"+obj.getDocPath() + "#" +
                                           "4"+obj.getClassPathString() + "\r\n");
      }
    }

    if(currentJdkInfo != null){
      buf.append("PM_Current_JDKInfo=" + "1"+currentJdkInfo.getJavaEXEPath() + "#" +
                                "2"+currentJdkInfo.getJavacEXEPath() + "#" +
                                "3"+currentJdkInfo.getAppletviewerEXEPath() + "#" +
                                "4"+currentJdkInfo.getSourcePath() + "#" +
                                "5"+currentJdkInfo.getDocPath() + "#" +
                                "6"+currentJdkInfo.getVersion() + "#" +
                                "7"+currentJdkInfo.getClassPathString() + "\r\n");
    }

    if(sourceRoot != null){
      buf.append("PM_Source_Root=" + sourceRoot + "\r\n");
    }

    if(outputRoot != null){
      buf.append("PM_Output_Root=" + outputRoot + "\r\n");
    }

    if(documentRoot != null) {
      buf.append("PM_Document_Root=" + documentRoot + "\r\n");
    }

    if(classPath != null){
      buf.append("PM_ClassPath=" + classPath + "\r\n");
    }

    if(loader != null){
      buf.append(loader.toString());
    }

    return buf.toString();
  }

  public DefaultPathModel(){
  }

  public synchronized Object clone(){
    try{
      DefaultPathModel model = (DefaultPathModel)super.clone();
      model.jdkInfos = (jdkInfos != null) ? (JdkInfoContainer)jdkInfos.clone() : null;
      model.allLibInfos = (allLibInfos != null) ? (LibInfoContainer)allLibInfos.clone() : null;
      model.selectedLibInfos = (selectedLibInfos != null) ? (LibInfoContainer)selectedLibInfos.clone() : null;
      model.currentJdkInfo = (currentJdkInfo != null) ? (JdkInfo)currentJdkInfo.clone() : null;
      model.sourceRoot = (sourceRoot != null) ? (String)sourceRoot : null;
      model.outputRoot = (outputRoot != null) ? (String)outputRoot : null;
      model.documentRoot = (documentRoot != null) ? (String)documentRoot : null;
      model.loader = (loader != null) ? (FileClassLoader)loader.clone() : null;
      model.classPath = (classPath != null) ? (String)classPath : null;
      return model;

    }catch(CloneNotSupportedException e){
      throw new InternalError();
    }
  }


  public String getSourceRoot(){
    if(sourceRoot == null || sourceRoot.trim().equals("")) return null;
    else return sourceRoot;
  }

  public String getOutputRoot(){
    if(outputRoot == null || outputRoot.trim().equals("")) return null;
    else return outputRoot;
  }

  public String getDocumentRoot(){
    if(documentRoot == null || documentRoot.trim().equals("")) return null;
    else return documentRoot;
  }

  public JdkInfo getCurrentJdkInfo(){
    if(currentJdkInfo == null) {
      return null;
    }
    else return (JdkInfo)currentJdkInfo.clone();
  }

  public JdkInfoContainer getJdkInfoContainer(){
    return (JdkInfoContainer)jdkInfos.clone();
  }

  public LibInfoContainer getAllLibInfoContainer(){
    return (LibInfoContainer)allLibInfos.clone();
  }

  public LibInfoContainer getSelectedLibInfoContainer(){
    return (LibInfoContainer)selectedLibInfos.clone();
  }

  public void setSourceRoot(String newRoot){
    sourceRoot = newRoot;
  }

  public void setOutputRoot(String newRoot){
    outputRoot = newRoot;
  }

  public void setDocumentRoot(String newRoot){
    documentRoot = newRoot;
  }

  public void setCurrentJdkInfo(JdkInfo info){
    currentJdkInfo = info;
  }

  public void setJdkInfoContainer(JdkInfoContainer jic){
    jdkInfos = jic;
  }

  public void setAllLibInfoContainer(LibInfoContainer lic){
    allLibInfos = lic;
  }

  public void setSelectedLibInfoContainer(LibInfoContainer lic){
    selectedLibInfos = lic;
  }

  public Vector getLibraryPoolDatas(){
    Vector ret = new Vector();

    if(currentJdkInfo != null){
      LibraryInfo info = new LibraryInfo(currentJdkInfo.getVersion());
      info.setNew(true);

      for(Enumeration e=currentJdkInfo.getClassPaths(); e.hasMoreElements(); ){
        String path = (String)e.nextElement();
        info.addLibraryPath(path);
      }
      ret.addElement(info);
    }

    for(int j=0; j<selectedLibInfos.getSize(); j++){
      LibInfo libInfo = (LibInfo)selectedLibInfos.getLibraryInfo(j);
      LibraryInfo info = new LibraryInfo(libInfo.getName());
      info.setNew(true);

      for(Enumeration e1=libInfo.getClassPaths(); e1.hasMoreElements(); ){
        String path = (String)e1.nextElement();
        info.addLibraryPath(path);
      }
      ret.addElement(info);
    }

    return ret;
  }

  public String getClassPath(){
    return classPath;
  }

  public String getSourcePath(){
    return "." + File.pathSeparator + getSourceRoot();
  }

  public void setClassPath(String path){
    classPath = path;
  }

  public void updateClassPath(){
    StringBuffer newClassPath = new StringBuffer();
    String pathSeparator = File.pathSeparator;
    String currentDir = "." + pathSeparator;

    //current directory
    newClassPath.append(currentDir);

    //output directory
    newClassPath.append(getOutputRoot() + pathSeparator);

    //jdk & library paths
    Vector libs = getLibraryPoolDatas();
    if(libs != null)
    for(int i=0; i<libs.size(); i++){
      LibraryInfo libInfo = (LibraryInfo)libs.elementAt(i);

      for(Enumeration e=libInfo.getPath(); e.hasMoreElements(); ){
        String path = (String)e.nextElement();
        newClassPath.append(path + pathSeparator);
      }
    }

    classPath = newClassPath.toString();
  }

  public FileClassLoader getClassLoader(){

    return loader;
  }

  public void setClassLoader(FileClassLoader loader){
    this.loader = loader;
  }

  public void updateClassLoader(){
    if(loader ==  null) loader = new FileClassLoader();
    else loader.removeAllPath();

    Vector libs = getLibraryPoolDatas();
    for(int i=0; i<libs.size(); i++){
      LibraryInfo libInfo = (LibraryInfo)libs.elementAt(i);
      for(Enumeration e=libInfo.getFiles(); e.hasMoreElements(); ){
        File file = (File)e.nextElement();
        String path = file.getAbsolutePath();
        loader.addPath(path);
      }
    }
  }
}
