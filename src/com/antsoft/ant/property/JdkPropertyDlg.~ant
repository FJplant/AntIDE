/*
 * $Header: /AntIDE/source/ant/property/JdkPropertyDlg.java 26    99-05-29 6:28p Remember $
 * Ant ( JDK wrapper Java IDE )
 * Version 1.0
 * Copyright (c) 1998-1999 Antsoft Co. All rights reserved.
 *  This program and source file is protected by Korea and international
 * Copyright laws.
 *
 * $Revision: 26 $
 * $History: JdkPropertyDlg.java $
 * 
 * *****************  Version 26  *****************
 * User: Remember     Date: 99-05-29   Time: 6:28p
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 25  *****************
 * User: Remember     Date: 99-05-22   Time: 4:03a
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 24  *****************
 * User: Remember     Date: 99-05-21   Time: 12:30p
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 22  *****************
 * User: Remember     Date: 99-05-20   Time: 10:55a
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 21  *****************
 * User: Remember     Date: 99-05-17   Time: 7:11a
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 20  *****************
 * User: Multipia     Date: 99-05-17   Time: 12:24a
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 19  *****************
 * User: Remember     Date: 99-05-15   Time: 5:36a
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 18  *****************
 * User: Remember     Date: 99-05-11   Time: 10:20a
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 17  *****************
 * User: Remember     Date: 99-05-10   Time: 9:34p
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 16  *****************
 * User: Remember     Date: 99-05-07   Time: 2:35p
 * Updated in $/AntIDE/source/ant/property
 * 
 * *****************  Version 14  *****************
 * User: Remember     Date: 99-05-06   Time: 2:46p
 * Updated in $/AntIDE/source/ant/property
 *
 * *****************  Version 8  *****************
 * User: Kahn         Date: 99-05-03   Time: 6:14p
 * Updated in $/AntIDE/source/ant/property
 * parameterizing 개선
 *
 * *****************  Version 7  *****************
 * User: Remember     Date: 99-05-03   Time: 4:24p
 * Updated in $/AntIDE/source/ant/property
 *
 * *****************  Version 5  *****************
 * User: Remember     Date: 99-04-29   Time: 5:58p
 * Updated in $/AntIDE/source/ant/property
 * 파일 존재 검사 추가
 *
 * *****************  Version 3  *****************
 * User: Multipia     Date: 99-04-29   Time: 12:32a
 * Updated in $/AntIDE/source/ant/property
 * JDK List Panel와 JDK Info 패널의 좌우 변경
 */
package com.antsoft.ant.property;

import javax.swing.event.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.Enumeration;
import java.util.Vector;
import java.util.StringTokenizer;
import java.util.Hashtable;
import java.util.zip.*;
import com.antsoft.ant.util.*;
import com.antsoft.ant.main.Main;
import com.antsoft.ant.manager.projectmanager.IdePropertyManager;

/**
 * jdk property를 설정하는 dialog
 *
 * @author kim sang kyun
 */

public class JdkPropertyDlg extends JDialog{
  private JTextField javaTf, classPathTf, sourcePathTf, docPathTf;
  private JButton javaBtn, classPathBtn, sourcePathBtn, docPathBtn,
                  cancelBtn, addBtn, removeBtn, editBtn, okBtn;
  private JList jdkList;
  private JdkListModel jdkListModel;
  private DefaultListSelectionModel jdkListSelectModel;

  private JFrame parent;
  private JdkInfoContainer jdkInfoContainer;
  private JLabel javaLbl, classPathLbl, sourcePathLbl, docPathLbl;
  private JScrollPane jdkPane;

  private JdkInfo selectedJdkInfo = null;
  private JdkInfo currentEditingJdkInfo = null;

  private Icon errorIcon = new ImageIcon(getClass().getResource("image/errorimage.gif"));
  private JdkInfoContainer jdkInfos;

  private boolean isOK = false;

  private Vector removedJdks;

  public JdkPropertyDlg(JFrame f, String title, boolean modal, JdkInfoContainer jdkInfos) {
    super(f, title, modal);
    
    addKeyListener(new KeyAdapter(){
      public void keyPressed(KeyEvent e){
        if(e.getKeyCode() == KeyEvent.VK_ESCAPE) dispose();
      }
    });

    this.jdkInfos = jdkInfos;
    this.parent = f;
    getContentPane().setLayout(new BorderLayout());
    ActionListener al = new ActionHandler();
    removedJdks = new Vector(3, 2);

    //right panel
    JPanel rightP = new JPanel(new BorderLayout());

    //left top panel
    Box rightTop = Box.createVerticalBox();

    //java.exe label

    if(System.getProperty("os.name").indexOf("Win") != -1)
      javaLbl = new JLabel("Java.EXE (Not in jre directory)", JLabel.LEFT);
    else
      javaLbl = new JLabel("Java (Not in jre directory)", JLabel.LEFT);

    javaLbl.setEnabled(false);
    javaLbl.setForeground(Color.black);
    JPanel javaLblP = new JPanel(new BorderLayout());
    javaLblP.add(javaLbl, BorderLayout.WEST);

    //java.exe text field
    javaTf = new JTextField(20);
    javaTf.setEnabled(false);
    javaTf.setFont(FontList.myTextFieldFont);
    javaBtn = new JButton("...");
    javaBtn.setMargin(new Insets(1, 2, 1, 2));
    javaBtn.setEnabled(false);

    javaBtn.setActionCommand("JAVA.EXE");
    javaBtn.addActionListener(al);

    JPanel javaP = new JPanel(new BorderLayout());
    javaP.add(javaTf, BorderLayout.CENTER);
    javaP.add(javaBtn, BorderLayout.EAST);

    //class path label
    classPathLbl = new JLabel("Class Path", JLabel.LEFT);
    classPathLbl.setEnabled(false);
    classPathLbl.setForeground(Color.black);
    JPanel classPathLblP = new JPanel(new BorderLayout());
    classPathLblP.add(classPathLbl, BorderLayout.WEST);

    //class path text field
    classPathTf = new JTextField(20);
    classPathTf.setFont(FontList.myTextFieldFont);
    classPathTf.setEnabled(false);
    classPathBtn = new JButton("...");
    classPathBtn.setMargin(new Insets(1, 2, 1, 2));
    classPathBtn.setEnabled(false);
    classPathBtn.setActionCommand("CLASSPATH");
    classPathBtn.addActionListener(al);

    JPanel classPathP = new JPanel(new BorderLayout());
    classPathP.add(classPathTf, BorderLayout.CENTER);
    classPathP.add(classPathBtn, BorderLayout.EAST);

    //source path label
    sourcePathLbl = new JLabel("Source Path", JLabel.LEFT);
    sourcePathLbl.setEnabled(false);
    sourcePathLbl.setForeground(Color.black);
    JPanel sourcePathLblP = new JPanel(new BorderLayout());
    sourcePathLblP.add(sourcePathLbl, BorderLayout.WEST);

    //source path text field
    sourcePathTf = new JTextField(20);
    sourcePathTf.setFont(FontList.myTextFieldFont);
    sourcePathTf.setEnabled(false);
    sourcePathBtn = new JButton("...");
    sourcePathBtn.setMargin(new Insets(1, 2, 1, 2));
    sourcePathBtn.setEnabled(false);
    sourcePathBtn.setActionCommand("SOURCE");
    sourcePathBtn.addActionListener(al);

    JPanel sourcePathP = new JPanel(new BorderLayout());
    sourcePathP.add(sourcePathTf, BorderLayout.CENTER);
    sourcePathP.add(sourcePathBtn, BorderLayout.EAST);

    //source path label
    docPathLbl = new JLabel("Doc Path");
    docPathLbl.setEnabled(false);
    docPathLbl.setForeground(Color.black);
    JPanel docPathLblP = new JPanel(new BorderLayout());
    docPathLblP.add(docPathLbl, BorderLayout.WEST);

    //source path text field
    docPathTf = new JTextField(20);
    docPathTf.setFont(FontList.myTextFieldFont);
    docPathTf.setEnabled(false);
    docPathBtn = new JButton("...");
    docPathBtn.setMargin(new Insets(1, 2, 1, 2));
    docPathBtn.setEnabled(false);
    docPathBtn.setActionCommand("DOC");
    docPathBtn.addActionListener(al);

    JPanel docPathP = new JPanel(new BorderLayout());
    docPathP.add(docPathTf, BorderLayout.CENTER);
    docPathP.add(docPathBtn, BorderLayout.EAST);

    //rightTop.add(javaLblP);
    rightTop.add(javaP);
    rightTop.add(classPathLblP);
    rightTop.add(classPathP);
    rightTop.add(sourcePathLblP);
    rightTop.add(sourcePathP);
    rightTop.add(docPathLblP);
    rightTop.add(docPathP);

    okBtn = new JButton("OK");
    okBtn.setActionCommand("OK");
    okBtn.addActionListener(al);

    cancelBtn = new JButton("Cancel");
    cancelBtn.setActionCommand("CANCEL");
    cancelBtn.addActionListener(al);

    JPanel buttonP = new JPanel(new FlowLayout(FlowLayout.LEFT));
    buttonP.add(okBtn);
    buttonP.add(cancelBtn);

    rightP.add(rightTop, BorderLayout.CENTER);
    rightP.add(buttonP, BorderLayout.SOUTH);

    //left panel
    JPanel leftP = new JPanel(new BorderLayout());
    leftP.setPreferredSize(new Dimension(225, 5));

    //jdk list label

    JLabel jdkListLbl = new JLabel("JDK List", JLabel.LEFT);
    jdkListLbl.setForeground(Color.black);
    JPanel jdkListLblP = new JPanel(new BorderLayout());
    jdkListLblP.add(jdkListLbl, BorderLayout.WEST);

    //jdk list
    jdkList = new JList();
    jdkList.setFont(FontList.myTextFieldFont);
    jdkListModel = new JdkListModel(jdkInfos);
    jdkList.setModel(jdkListModel);

    ListSelectionListener lsl = new ListSelectionHandler();
    jdkListSelectModel = new DefaultListSelectionModel();
    jdkListSelectModel.addListSelectionListener(lsl);
    jdkList.setSelectionModel(jdkListSelectModel);

    //jdk list scroll pane
    jdkPane = new JScrollPane(jdkList);

    //jdk list button panel
    JPanel jdkBtnP = new JPanel();

    addBtn = new JButton("Add");
    addBtn.setActionCommand("ADD");
    addBtn.addActionListener(al);

    removeBtn = new JButton("Remove");
    removeBtn.setActionCommand("REMOVE");
    removeBtn.addActionListener(al);

    editBtn = new JButton("Edit");
    editBtn.setActionCommand("EDIT");
    editBtn.addActionListener(al);

    okBtn = new JButton("OK");
    okBtn.setActionCommand("OK");
    okBtn.addActionListener(al);

    jdkBtnP.add(new JPanel(new FlowLayout(FlowLayout.RIGHT)));
    jdkBtnP.add(addBtn);
    jdkBtnP.add(removeBtn);
    jdkBtnP.add(editBtn);

    leftP.add(jdkListLblP, BorderLayout.NORTH);
    leftP.add(jdkPane, BorderLayout.CENTER);
    leftP.add(jdkBtnP, BorderLayout.SOUTH);

    //top panel
    JPanel topP = new JPanel(new BorderLayout(185,0));
    topP.add(javaLblP, BorderLayout.CENTER);
    topP.add(jdkListLblP, BorderLayout.WEST);

    //center panel
    JPanel centerP = new JPanel(new BorderLayout(10,1));
    centerP.add(leftP, BorderLayout.WEST);
    centerP.add(rightP, BorderLayout.CENTER);

    //main panel
    JPanel mainP = new JPanel(new BorderLayout());
    mainP.setBorder(BorderList.etchedBorder10);
    mainP.add(topP, BorderLayout.NORTH);
    mainP.add(centerP, BorderLayout.CENTER);

    //focus setting
    javaTf.setNextFocusableComponent(classPathTf);
    classPathTf.setNextFocusableComponent(sourcePathTf);
    sourcePathTf.setNextFocusableComponent(docPathTf);

    getContentPane().add(mainP, BorderLayout.CENTER);
    getContentPane().add(new JPanel(), BorderLayout.NORTH);
    getContentPane().add(new JPanel(), BorderLayout.EAST);
    getContentPane().add(new JPanel(), BorderLayout.WEST);
    getContentPane().add(new JPanel(), BorderLayout.SOUTH);
  }

  public boolean isOk(){
    return isOK;
  }

  public JdkInfoContainer getJdkInfos(){
    return this.jdkInfos;
  }

  public JdkInfo getSelectedJdkInfo(){
    return selectedJdkInfo;
  }

  public void classPathBtnSelected(){

    ExtensionFileFilter filter = new ExtensionFileFilter();
    filter.addExtension("jar");
    filter.addExtension("zip");

    JFileChooser filechooser = new JFileChooser();

    filechooser.setFileFilter(filter);
    filechooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
    filechooser.setMultiSelectionEnabled(false);
    filechooser.setPreferredSize(new Dimension(400, 300));
    filechooser.setApproveButtonText("Select");
    filechooser.setApproveButtonToolTipText("ClassPath");
    filechooser.setBorder(BorderList.lightLoweredBorder);
    filechooser.setDialogTitle("ClassPath");

    if(filechooser.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
      File f = filechooser.getSelectedFile();

      if(!classPathTf.getText().equals("")){
        classPathTf.setText(classPathTf.getText() + ", " + f.getAbsolutePath());
      }
      else{
        classPathTf.setText(f.getAbsolutePath());
      }
    }
  }

  public void sourceBtnSelected(){

    ExtensionFileFilter filter = new ExtensionFileFilter();
    filter.addExtension("jar");
    filter.addExtension("zip");

    JFileChooser filechooser = new JFileChooser();
    filechooser.setFileFilter(filter);

    filechooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
    filechooser.setPreferredSize(new Dimension(400, 300));
    filechooser.setApproveButtonText("Select");
    filechooser.setApproveButtonToolTipText("Select JDK Source Directory");
    filechooser.setBorder(BorderList.lightLoweredBorder);
    filechooser.setDialogTitle("Output Root Directory");

    if(filechooser.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
      File f = filechooser.getSelectedFile();
      sourcePathTf.setText(f.getAbsolutePath());
    }
  }

  public void docBtnSelected(){

    JFileChooser filechooser = new JFileChooser();
    filechooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
    filechooser.setPreferredSize(new Dimension(400, 300));
    filechooser.setApproveButtonText("Select");
    filechooser.setApproveButtonToolTipText("Select JDK Doc Directory");
    filechooser.setBorder(BorderList.lightLoweredBorder);
    filechooser.setDialogTitle("Output Root Directory");

    if(filechooser.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
      File f = filechooser.getSelectedFile();
      docPathTf.setText(f.getAbsolutePath());
    }
  }

  public void javaBtnSelected(){
    NameFileFilter filter = null;

    if(System.getProperty("os.name").indexOf("Win") != -1)
      filter = new NameFileFilter("java.exe", "java.exe");
    else
      filter = new NameFileFilter("java", "java");


    JFileChooser filechooser = new JFileChooser();
    filechooser.setFileFilter(filter);
    filechooser.setPreferredSize(new Dimension(400, 300));
    filechooser.setApproveButtonText("Select");
    filechooser.setApproveButtonToolTipText("Select JDK Doc Directory");
    filechooser.setBorder(BorderList.lightLoweredBorder);
    filechooser.setDialogTitle("Output Root Directory");

    if(filechooser.showOpenDialog(parent) == JFileChooser.APPROVE_OPTION) {
      File f = filechooser.getSelectedFile();
      javaTf.setText(f.getAbsolutePath());

      try{
        String [] command = {f.getAbsolutePath(), "-version"};
  			process = Runtime.getRuntime().exec(command);

        try{ process.waitFor(); }
        catch(InterruptedException e){}

        process.getOutputStream().close();
        process.getInputStream().close();
  		}
	  	catch(IOException io){ return; }
      stderr = new StderrThread();
    }
  }

  private Process process;
  private StderrThread stderr;
  private String currJdkVersion = null;
  class StderrThread extends Thread
	{
		StderrThread(){ start();	}

		public void run(){

			try
			{
				BufferedReader err = new BufferedReader(	new InputStreamReader(process.getErrorStream()));
        SwingUtilities.invokeLater(new SafeAppend(err.readLine()));
				err.close();
			}
			catch(IOException io){}
		}
	}

  class SafeAppend implements Runnable
	{
		private String jdkVersion;

		SafeAppend(String msg){	jdkVersion = msg;	}

		public void run(){
      currJdkVersion = jdkVersion;
      String javaexePath = javaTf.getText();
      String javaexeLowerpath =  javaTf.getText().toLowerCase();
      File javaexe = new File(javaexePath);
      File javaHome = null;
      File classPath = null;
      File sourcePath = null;
      File docPath = null;

      File parent1 = new File(javaexe.getParent());
      File parent2 = new File(parent1.getParent());

      javaHome = parent2;

      //jdk1.0 or jdk1.1
      if(currJdkVersion.indexOf("1.1") != -1 || currJdkVersion.indexOf("1.0") != -1){
        //set classpath
        classPath = new File(javaHome.getAbsolutePath() + File.separator +"lib"+File.separator+"classes.zip");
        if(classPath.exists()) classPathTf.setText(classPath.getAbsolutePath());

        //set source path
        sourcePath = new File(javaHome.getAbsolutePath() + File.separator +"src");
        if(sourcePath.exists()) sourcePathTf.setText(sourcePath.getAbsolutePath());

        //set doc path
        docPath = new File(javaHome.getAbsolutePath() + File.separator +"docs"+File.separator+"api");
        if(docPath.exists()) docPathTf.setText(docPath.getAbsolutePath());

      }
      //jdk1.2
      else if(currJdkVersion.indexOf("1.2") != -1){
        classPath = new File(javaHome.getAbsolutePath() + File.separator +"jre"+File.separator+"lib"+File.separator+"rt.jar");
        if(classPath.exists()) classPathTf.setText(classPath.getAbsolutePath());

        //set source path
        sourcePath = new File(javaHome.getAbsolutePath() + File.separator +"src.jar");
        if(sourcePath.exists()) sourcePathTf.setText(sourcePath.getAbsolutePath());

        //set doc path
        docPath = new File(javaHome.getAbsolutePath() + File.separator +"docs"+File.separator+"api");
        if(docPath.exists()) docPathTf.setText(docPath.getAbsolutePath());
      }
		}
	}

  public void editBtnSelected(){
    JdkInfo jdkInfo = (JdkInfo)jdkListModel.getElementAt(jdkList.getSelectedIndex());
    this.currentEditingJdkInfo = jdkInfo;
    this.currJdkVersion = jdkInfo.toString();

    javaTf.setText(jdkInfo.getJavaEXEPath());
    classPathTf.setText(jdkInfo.getClassPathString());
    sourcePathTf.setText(jdkInfo.getSourcePath());
    docPathTf.setText(jdkInfo.getDocPath());
  }

  public void removeBtnSelected(){
    if(jdkListModel.getSize() > 0 && !jdkListSelectModel.isSelectionEmpty())
    {
      removedJdks.addElement(jdkListModel.getElementAt(jdkList.getSelectedIndex()));
      jdkListModel.removeElementAt(jdkList.getSelectedIndex());
    }

    setEnableFlag(false);
    setEmptyFieldEnabled();
  }

  public boolean doneBtnSelected(){
    File javac = new File(javaTf.getText());
    File classPath = new File(classPathTf.getText());
    File source = new File(sourcePathTf.getText());
    File doc = new File(docPathTf.getText());
    boolean isfalse = true;

    if(javaTf.getText().equals(""))
    JOptionPane.showMessageDialog(null, "JAVA.EXE not specified!!", "Error", JOptionPane.ERROR_MESSAGE, errorIcon );

    else if(classPathTf.getText().equals(""))
    JOptionPane.showMessageDialog(null, "CLASSPATH not specified!!", "Error", JOptionPane.ERROR_MESSAGE, errorIcon );

    else if(!javac.exists() || !javaTf.getText().endsWith("java.exe"))
    JOptionPane.showMessageDialog(null, "JAVA.EXE Path not avaliable", "Error", JOptionPane.ERROR_MESSAGE, errorIcon );

    else if(classPathTf.getText().length() > 0 && !classPath.exists())
    JOptionPane.showMessageDialog(null, "Class Path not avaliable", "Error", JOptionPane.ERROR_MESSAGE, errorIcon );

    else if(sourcePathTf.getText().length() > 0 && !source.exists())
    JOptionPane.showMessageDialog(null, "Source Path not avaliable", "Error", JOptionPane.ERROR_MESSAGE, errorIcon );

    else if(docPathTf.getText().length() > 0 && !doc.exists())
    JOptionPane.showMessageDialog(null, "Doc Path not avaliable", "Error", JOptionPane.ERROR_MESSAGE, errorIcon );

    else
    {
      isfalse = false;
      addJdkInfo();

    }

    if(source.exists()){
       SourceBrowser sb = new SourceBrowser(source, "");
       Thread t = new SourceBrowser(source, "");
       t.start();
    }

    return isfalse;
  }


  static int count=0;

  class SourceBrowser extends Thread{

    File root;
    String prefix;
    ProgressMonitor monitor;
    int index=0;

    public SourceBrowser(File root, String prefix){
      this.root = root;
      this.prefix = prefix;
    }

    public void run(){

      monitor = new ProgressMonitor(JdkPropertyDlg.this, "Extracting param from source!!", "Please wait...", 0, 100);
      monitor.setMillisToDecideToPopup(0);
      monitor.setMillisToPopup(0);
      SwingUtilities.invokeLater(new Runnable() {
        public void run(){
          for(index=0;index<10; index++) {
            monitor.setNote("preparing param extracting ....");
          }
        }
      });

      checkFileCount(root);
      monitor.setMaximum(count);

      //Main의 ParamLoader Thread가 일을 끝낼때 까지 기다린다
      while(!Main.isParamLoadEnd){
        try{ sleep(500);}
        catch(InterruptedException e){ return; }
      }

      browseSource(root, prefix);
      monitor.setProgress(count);
      monitor.close();

      count = 0;
      index = 0;
      IdePropertyManager.saveParamHash(Main.paramHash);

      //Garbage collecting...
      Runtime rt=Runtime.getRuntime();
      for(int i=0; i<5; i++) rt.gc();
    }

    private void checkFileCount(File root){
      if(root.isDirectory()){
        String [] dirs = root.list();
        for(int i=0; i<dirs.length; i++){
          File ele = new File(root, dirs[i]);

          if(ele.isDirectory()) checkFileCount(ele);
          else if(dirs[i].endsWith(".java")) ++count;
        }
      }
      else{
        try{
          ZipFile zip = new ZipFile(root);
          for(Enumeration e=zip.entries(); e.hasMoreElements(); ) {
             e.nextElement();
             ++count;
          }

        }catch(IOException e){}
      }
    }

    private void browseSource(File root, String prefix){

      if(root.isDirectory()){
        String [] dirs = root.list();
        for(int i=0; i<dirs.length; i++){
          File ele = new File(root, dirs[i]);

          if(ele.isDirectory()) browseSource(ele, prefix + dirs[i]+".");
          else if(dirs[i].endsWith(".java")){

            final String msg = dirs[i];
            SwingUtilities.invokeLater(new Runnable() {
              public void run(){
                monitor.setProgress( index++ );
                monitor.setNote("processing : "+ msg);
                if(monitor.isCanceled()) return;
              }
            });

            try{
              BufferedReader br = new BufferedReader(new FileReader(ele));
              ParamExtractor.setData(prefix+dirs[i].substring(0, dirs[i].indexOf(".java")), br, Main.paramHash);
            }catch(IOException e){}
          }
        }
      }
      else{
        try{
          ZipFile zip = new ZipFile(root);
          for(Enumeration e=zip.entries(); e.hasMoreElements(); ){
            ZipEntry entry = (ZipEntry)e.nextElement();
            monitor.setProgress( index++ );
            monitor.setNote("processing : "+ entry.getName().substring(entry.getName().indexOf("/")+1));
            BufferedReader br = new BufferedReader( new InputStreamReader(zip.getInputStream(entry)) );
            if(entry.getName().indexOf(".") != -1)
              ParamExtractor.setData(entry.getName().substring(entry.getName().indexOf("/")+1,entry.getName().lastIndexOf(".")), br, Main.paramHash);
            else
              ParamExtractor.setData(entry.getName().substring(entry.getName().indexOf(",")+1), br, Main.paramHash);
          }
        }catch(IOException e){}
      }
    }
  }

  private void addJdkInfo(){

    Vector classPath = new Vector();
    StringTokenizer st = new StringTokenizer(classPathTf.getText(), "," , false);
    if(st.countTokens() == 0)
      classPath.addElement(classPathTf.getText());

    else
      while(st.hasMoreTokens()) classPath.addElement(st.nextToken());

    if(this.currentEditingJdkInfo == null)
    {
      JdkInfo jdkInfo = null;
      if(currJdkVersion != null)
        jdkInfo = new JdkInfo(javaTf.getText(), classPath, sourcePathTf.getText(),
                              docPathTf.getText(), currJdkVersion);
      else
        jdkInfo = new JdkInfo(javaTf.getText(), classPath, sourcePathTf.getText(),
                              docPathTf.getText(), javaTf.getText());

      if(!jdkListModel.exist(jdkInfo)) jdkListModel.addElement(jdkInfo);
    }

    else
    {
      currentEditingJdkInfo.setJavaEXEPath(javaTf.getText());
      currentEditingJdkInfo.setClassPath(classPath);
      currentEditingJdkInfo.setSourcePath(sourcePathTf.getText());
      currentEditingJdkInfo.setDocPath(docPathTf.getText());

      //Runtime.exec가 실패했는지를 체크한다
      if(currJdkVersion != null) currentEditingJdkInfo.setVersion(currJdkVersion);
      else currentEditingJdkInfo.setVersion(javaTf.getText());

      currJdkVersion = null;
      jdkListModel.fireUpdate(currentEditingJdkInfo, jdkList.getSelectedIndex());
      currentEditingJdkInfo = null;
    }

    currJdkVersion = null;
    setEnableFlag(false);
    setEmptyFieldEnabled();
  }

  public void okBtnSelected(){
    if(javaTf.isEnabled()) doneBtnSelected();
    else
    {
      if(!jdkList.isSelectionEmpty())
      this.selectedJdkInfo = (JdkInfo)jdkListModel.getElementAt(jdkList.getSelectedIndex());

      this.isOK = true;
      dispose();
    }
  }

  public Vector getRemovedJdks(){
    return this.removedJdks;
  }

  /** jdklist selection event handler */
  class ListSelectionHandler implements ListSelectionListener{

    public void valueChanged(ListSelectionEvent e){
      JdkInfo selectedJdk = (JdkInfo)jdkListModel.getElementAt(jdkList.getSelectedIndex());
      setEnableFlag(false);

      javaTf.setText(selectedJdk.getJavaEXEPath());
      classPathTf.setText(selectedJdk.getClassPathString());
      sourcePathTf.setText(selectedJdk.getSourcePath());
      docPathTf.setText(selectedJdk.getDocPath());
    }
  }

  private void setEnableFlag(boolean flag){
    javaTf.setEnabled(flag);
    classPathTf.setEnabled(flag);
    sourcePathTf.setEnabled(flag);
    docPathTf.setEnabled(flag);

    javaBtn.setEnabled(flag);
    classPathBtn.setEnabled(flag);
    sourcePathBtn.setEnabled(flag);
    docPathBtn.setEnabled(flag);

    javaLbl.setEnabled(flag);
    classPathLbl.setEnabled(flag);
    sourcePathLbl.setEnabled(flag);
    docPathLbl.setEnabled(flag);
  }

  private void setEmptyFieldEnabled(){
    javaTf.setText("");
    classPathTf.setText("");
    sourcePathTf.setText("");
    docPathTf.setText("");
  }

  /** action event handler */
  class ActionHandler implements ActionListener{

    public void actionPerformed(ActionEvent e){
      String cmd = e.getActionCommand();

      if(cmd.equals("JAVA.EXE")) javaBtnSelected();
      else if(cmd.equals("CLASSPATH")) classPathBtnSelected();
      else if(cmd.equals("SOURCE")) sourceBtnSelected();
      else if(cmd.equals("DOC")) docBtnSelected();
      else if(cmd.equals("ADD"))
      {
        setEnableFlag(true);
        setEmptyFieldEnabled();
        javaTf.requestFocus();
      }

      else if(cmd.equals("EDIT"))
      {
        if(!jdkListSelectModel.isSelectionEmpty())
        {
          setEnableFlag(true);
          javaTf.requestFocus();
          editBtnSelected();
        }
      }

      else if(cmd.equals("OK")) okBtnSelected();
      else if(cmd.equals("REMOVE")){
        if(!jdkListSelectModel.isSelectionEmpty()) removeBtnSelected();
      }

      else if(cmd.equals("CANCEL")){
        isOK = false;
        dispose();
      }
    }
  }
}
