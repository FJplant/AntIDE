/*
 * Ant ( JDK wrapper Java IDE )
 * Version 1.0
 * Copyright (c) 1998-1999 Antsoft Co. All rights reserved.
 *  This program and source file is protected by Korea and international
 * Copyright laws.
 *
 * Author:       Kwon, Young Mo
 * $Header: /AntIDE/source/ant/debugger/LoadedClassesPanel.java 2     99-05-16 11:42p Multipia $
 * $Revision: 2 $
 * $History: LoadedClassesPanel.java $
 * 
 * *****************  Version 2  *****************
 * User: Multipia     Date: 99-05-16   Time: 11:42p
 * Updated in $/AntIDE/source/ant/debugger
 * 
 * *****************  Version 1  *****************
 * User: Multipia     Date: 99-05-11   Time: 6:48p
 * Created in $/AntIDE/source/ant/debugger
 * Initial Version.
 */

package com.antsoft.ant.debugger;

import java.awt.*;
import java.util.Vector;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.event.*;

import sun.tools.debug.*;

/**
 * Remote Java Virtual Machine 상에 load된 class들의 리스트를 보여 주는 패널
 */
public class LoadedClassesPanel extends JPanel implements ActionListener{
  private DebuggerProxy debuggerProxy;
  private MethodPanel methodPanel;
  private SourcePanel sourcePanel;
  private JList classList = new JList();
  private JTree classTree = null;
  private DefaultListModel classesListModel = new DefaultListModel();
  private LoadedClassesTreeModel classesTreeModel = null;
  private JScrollPane classScrollPane = null;
  private JLabel status = new JLabel("Loaded Classes: 0, Loaded Interfaces: 0");
  private int loadedClasses, loadedInterfaces;

  BorderLayout borderLayout1 = new BorderLayout();

  JButton showListButton, showTreeButton;
  String listActionCommand = "Show List Type";
  String treeActionCommand = "Show Tree Type";

  static Icon listIcon = new ImageIcon(LoadedClassesPanel.class.getResource("image/list.gif"));
  static Icon treeIcon = new ImageIcon(LoadedClassesPanel.class.getResource("image/tree.gif"));

  //처음 보여주는 형식은 List 형태입니다.
  boolean isList = true;

  private AntDebuggerMainFrame mainFrame;
  private RemoteDebugger remoteDebugger;

  public LoadedClassesPanel( DebuggerProxy debugger, SourcePanel sourcePanel, MethodPanel methodPanel ) {
    debuggerProxy = debugger;
    this.sourcePanel = sourcePanel;
    this.methodPanel = methodPanel;
    classesTreeModel = new LoadedClassesTreeModel();
    
    try  {
//      this.remoteDebugger = remoteDebugger;
//      this.mainFrame = frame;
      uiInit();
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
  }

  void uiInit() throws Exception {
    this.setLayout(borderLayout1);

    JPanel upPane = new JPanel();
    upPane.setLayout(new BorderLayout(0,0));
    JPanel upleftPane = new JPanel();

    //showListButton = new JButton("List");
    showListButton = new JButton(listIcon);
    showListButton.setToolTipText("List의 형태로 보여줍니다.");
    showListButton.setMargin(new Insets(0, 0, 0, 0));
    //showListButton.setMaximumSize(new Dimension(listIcon.getIconWidth() ,listIcon.getIconHeight()));

    showListButton.setActionCommand(listActionCommand);
    showListButton.addActionListener(this);

	  //showTreeButton = new JButton("Tree");
  	showTreeButton = new JButton(treeIcon);
	  showTreeButton.setToolTipText("Tree의 형태로 보여줍니다.");
  	showTreeButton.setMargin(new Insets(0, 0, 0, 0));
    showTreeButton.setActionCommand(treeActionCommand);
    showTreeButton.addActionListener(this);

    upPane.add(new JLabel("Loaded Classes"), BorderLayout.WEST);
    upleftPane.add(showListButton);
    upleftPane.add(showTreeButton);
   	upPane.add(upleftPane, BorderLayout.EAST);

    //add(new JLabel("Loaded Classes:"), BorderLayout.NORTH);
    classList.setModel( classesListModel );
    //classTree.setModel( classesTreeModel );
    add(upPane, BorderLayout.NORTH);
    classScrollPane = new JScrollPane();

    classTree = new JTree(classesTreeModel);
    //classTree.setRootVisible(false);
    //classTree.setShowsRootHandles( false );

    setPreferredSize( new Dimension( 200, 150 ) );
  
		if ( isList )
			classScrollPane.setViewportView(classList);
		else
		  classScrollPane.setViewportView(classTree);
 
    add(classScrollPane, BorderLayout.CENTER);
    add(status, BorderLayout.SOUTH);

    MouseListener mouseListener = new MouseAdapter() {
      public void mouseClicked(MouseEvent e) {
        System.out.println("clicked..");
        Component comp = classScrollPane.getViewport().getView();
        
        String classId = null;
        int index = classList.locationToIndex(e.getPoint());
        classList.setSelectedIndex(index);
        classId = (String)classList.getSelectedValue();
      
        if ( classId != null ) {
          methodPanel.setClass(classId);
          sourcePanel.setClass(classId);
        }        
      }
    };    
    classList.addMouseListener(mouseListener);

    classTree.addTreeSelectionListener( new TreeSelectionListener() {
  		public void valueChanged( TreeSelectionEvent e ) {
	  		//TO DO 
        TreePath path = e.getPath();
        if ( path.getPathCount() < 3 ) return;
        
        String classId = (String)((DefaultMutableTreeNode)path.getPathComponent(1)).getUserObject();
        classId += "." + (String)((DefaultMutableTreeNode)path.getPathComponent(2)).getUserObject();            
        if ( classId != null ) {
          methodPanel.setClass(classId);
          sourcePanel.setClass(classId);
        }
		  }
  	});
  	
    try {
      update();
    } catch ( Exception e ) {
    }
  }

  public void update() throws Exception {
    // Load된 class들을 list에 넣습니다.
    classesListModel.removeAllElements();
    RemoteClass[] list = debuggerProxy.getRemoteDebugger().listClasses();

    //여기서 classListModel과 classTreeModel에 load된 class들을
    // 잘 넣어야 함다.
    loadedClasses = loadedInterfaces = 0;
    for (int i = 0 ; i < list.length ; i++) {
      StringBuffer desc = new StringBuffer();
      desc.append(list[i].getName());
      if ( list[i].isInterface() ) {
        //desc.append("(I)");
        loadedInterfaces++;
      } else {
        //desc.append("(C)");
        loadedClasses++;
      }

      //classes.addElement(list[i].description());
      if ( isList ) {
        // List에 추가
        classesListModel.addElement(desc.toString());
      } else {
        // tree에 추가.
        classesTreeModel.addClass(desc.toString());
      }
    }
    
    StringBuffer buf = new StringBuffer();
    buf.append("Classes: " + loadedClasses );
    buf.append(", ");
    buf.append("Interfaces: " + loadedInterfaces );

    status.setText(buf.toString());
  }

  public void actionPerformed(ActionEvent evt){
  	String LF = evt.getActionCommand();
  	if(LF.equals(treeActionCommand)){
  		if(isList){
  			//System.out.println(listActionCommand);
        //지금 tree의 형태로 보여 주면 됨니다.
        classScrollPane.setViewportView(classTree);
  			isList = false;
  		}

  	} else if(LF.equals(listActionCommand)){
  		if(!isList){
  			//System.out.println(listActionCommand);
        classScrollPane.setViewportView(classList);
  			isList = true;
  		}
  	}
  	try {
	    update();
	  } catch (Exception e){
	    // currently just skip it.
	  }
  }
}
