/*
 * $Header: /AntIDE/source/ant/manager/projectmanager/ProjectManager.java 11    99-06-02 4:33p Strife $
 * Ant ( JDK wrapper Java IDE )
 * Version 1.0
 * Copyright (c) 1998-1999 Antsoft Co. All rights reserved.
 *  This program and source file is protected by Korea and international
 * Copyright laws.
 *
 * $Revision: 11 $
 * IDE에서 프로젝트들을 관리하는 모듈
 */

package com.antsoft.ant.manager.projectmanager;

import java.io.*;
import java.util.Vector;
import java.util.StringTokenizer;
import javax.swing.tree.*;

import com.antsoft.ant.main.*;
import com.antsoft.ant.property.*;
import com.antsoft.ant.property.projectproperty.*;
import com.antsoft.ant.util.FileClassLoader;
/**
 *  class ProjectManager
 *
 *  @author Jinwoo Baek
 */
public class ProjectManager {
  static private Vector projects = new Vector(1, 1);
	static private Project current = null;

	/**
	 *  새로운 프로젝트를 생성할 때
	 *
	 *  @param pathName 생성할 프로젝트 파일 경로
	 *  @param fileName 생성할 프로젝트 이름
	 */
  static public Project newProject(String pathName, String prjName, String comment) {
//		System.out.println(pathName + prjName);
		Project prj = new Project(prjName, pathName);
		if (prj != null) {
			projects.addElement(prj);
			prj.setPathModel(Main.property.getPathModelClone());
      File f = new File(pathName);
      ((DefaultPathModel)prj.getPathModel()).setSourceRoot(f.getParent());
      ((DefaultPathModel)prj.getPathModel()).setOutputRoot(f.getParent());
      prj.setComment(comment);
		}
		return getProject(prjName);
  }

	/**
	 *  이름으로 프로젝트 객체를 얻는다.
	 */
  static public Project getProject(String prjName) {
    Project prj = findProject(prjName);
    return prj;
  }

	/**
	 *  파일로부터 프로젝트 객체를 연다.
	 */
  static public Project openProject(String pathName, String fileName) {
		Project prj = null;
		if ((pathName != null) && (fileName != null) && fileName.toLowerCase().endsWith(".apr")) {
			try {
        File projFile = new File(pathName, fileName);
	    	prj = new Project("", projFile.getCanonicalPath());
        DefaultPathModel pathModel = new DefaultPathModel();
        LibInfoContainer alic = new LibInfoContainer();
        LibInfoContainer slic = new LibInfoContainer();
        JdkInfoContainer ajic = new JdkInfoContainer();
        CompilerOptionModel compilerModel = new CompilerOptionModel();
        InterpreterOptionModel interpreterModel = new InterpreterOptionModel();
        DefaultTreeModel treeModel = null;
        MutableTreeNode parent = null;

        LineNumberReader in = new LineNumberReader(new FileReader(projFile));
        String line = null;
        while ((line = in.readLine()) != null) {
        	StringTokenizer st = new StringTokenizer(line);
          String key = st.nextToken("=");

          // key 값에 따라 적당하게 프로젝트의 데이터들을 채운다.
          if (key.equals("ProjectName")) {
          	if (st.hasMoreElements()) {
	          	prj.setProjectName(st.nextToken());
  	          treeModel = new DefaultTreeModel(new DefaultMutableTreeNode(prj.getProjectName()));
    	        parent = (MutableTreeNode)treeModel.getRoot();
            }
          } else if (key.equals("Comment")) {
          	if (st.hasMoreElements()) {
	          	prj.setComment(st.nextToken());
            }
          } else if (key.equals("LastID")) {
          	if (st.hasMoreElements()) {
	          	try {
		          	prj.setLastID(Long.parseLong(st.nextToken()));
    	        } catch (NumberFormatException e) {
      	      	prj.setLastID(0L);
        	    }
            }
          // 폴더일 경우
          } else if (key.equals("Folder")) {
          	if (st.hasMoreElements()) {
	          	String id = st.nextToken("#");
  	          String name = st.nextToken("#");
    	        String pid = st.nextToken("#");
      	      ProjectPanelTreeNode pptn = new ProjectPanelTreeNode(name);
        	    pptn.setID(id);
          	  pptn.setParentID(pid);
            	TreeNode[] nodes = treeModel.getPathToRoot(parent);
	            for (int i = 0; i < nodes.length; i++) {
  	          	if (nodes[i] instanceof ProjectPanelTreeNode) {
    	          	ProjectPanelTreeNode n = (ProjectPanelTreeNode)nodes[i];
      	          if (pid.equals(n.getID())) { parent = n; break; }
        	      }
          	    else parent = (MutableTreeNode)treeModel.getRoot();
            	}
              if ((treeModel != null) && (parent != null))
		            treeModel.insertNodeInto(pptn, parent, parent.getChildCount());
  	          parent = pptn;
            }
          // 파일일 경우
          } else if (key.equals("File")) {
          	if (st.hasMoreElements()) {
	          	String id = st.nextToken("#");
  	          File f = new File(st.nextToken("#"));
              String pid = st.nextToken("#");
    	        ProjectFileEntry pfe = new ProjectFileEntry(f.getParent(), f.getName());
      	      pfe.setID(id);
        	    pfe.setParent(pid);
          	  prj.addFile(pfe);
            	TreeNode[] nodes = treeModel.getPathToRoot(parent);
	            for (int i = 0; i < nodes.length; i++) {
  	          	if (nodes[i] instanceof ProjectPanelTreeNode) {
    	          	ProjectPanelTreeNode n = (ProjectPanelTreeNode)nodes[i];
      	          if (pid.equals(n.getID())) { parent = n; break; }
        	      }
          	    else parent = (MutableTreeNode)treeModel.getRoot();
            	}
              if ((treeModel != null) && (parent != null))
  	          	treeModel.insertNodeInto(new ProjectPanelTreeNode(pfe), parent, parent.getChildCount());
            }
          } else if (key.equals("PM_AllLib_Infos")) {
          	if (st.hasMoreElements()) {
	          	String name = st.nextToken("#");
  	          String sourcePath = st.nextToken("#");
    	        String docPath = st.nextToken("#");
      	      Vector classPath = new Vector();
        	    while (st.hasMoreElements()) classPath.addElement(st.nextToken(",").trim());
          		LibInfo libinfo = new LibInfo(name, classPath, sourcePath, docPath);
            	alic.addLibraryInfo(libinfo);
            }
          } else if (key.equals("PM_JDK_Infos")) {
          	if (st.hasMoreElements()) {
	          	String java = st.nextToken("#");
  	          String javac = st.nextToken("#");
    	        String applet = st.nextToken("#");
      	      String sourcePath = st.nextToken("#");
        	    String docPath = st.nextToken("#");
          	  String version = st.nextToken("#");
            	Vector classPath = new Vector();
	            while (st.hasMoreElements()) classPath.addElement(st.nextToken(",").trim());
  	        	JdkInfo jdkInfo = new JdkInfo(java, classPath, sourcePath, docPath, version);
    	        jdkInfo.setAppletviewerEXEPath(applet);
      	      jdkInfo.setJavacEXEPath(javac);
        	    ajic.addJdkInfo(jdkInfo);
            }
          } else if (key.equals("PM_Selected_Lib_Infos")) {
          	if (st.hasMoreElements()) {
	          	String name = st.nextToken("#");
  	          String sourcePath = st.nextToken("#");
    	        String docPath = st.nextToken("#");
      	      Vector classPath = new Vector();
        	    while (st.hasMoreElements()) classPath.addElement(st.nextToken(",").trim());
          		LibInfo libinfo = new LibInfo(name, classPath, sourcePath, docPath);
            	slic.addLibraryInfo(libinfo);
            }
          } else if (key.equals("PM_Current_JDKInfo")) {
          	if (st.hasMoreElements()) {
	          	String java = st.nextToken("#");
  	          String javac = st.nextToken("#");
    	        String applet = st.nextToken("#");
      	      String sourcePath = st.nextToken("#");
        	    String docPath = st.nextToken("#");
          	  String version = st.nextToken("#");
            	Vector classPath = new Vector();
	            while (st.hasMoreElements()) classPath.addElement(st.nextToken(",").trim());
  	        	JdkInfo jdkInfo = new JdkInfo(java, classPath, sourcePath, docPath, version);
    	        jdkInfo.setAppletviewerEXEPath(applet);
      	      jdkInfo.setJavacEXEPath(javac);
        	    pathModel.setCurrentJdkInfo(jdkInfo);
            }
          } else if (key.equals("PM_Source_Root")) {
          	if (st.hasMoreElements()) {
	          	pathModel.setSourceRoot(st.nextToken("#"));
            }
          } else if (key.equals("PM_Output_Root")) {
	         	if (st.hasMoreElements()) {
  	        	pathModel.setOutputRoot(st.nextToken("#"));
            }
          } else if (key.equals("PM_ClassPath")) {
          	if (st.hasMoreElements()) {
	          	pathModel.setClassPath(st.nextToken("#"));
            }
          } else if (key.equals("PM_FileClassLoader")) {
          	if (st.hasMoreElements()) {
	          	FileClassLoader fcl = new FileClassLoader();
  	          while (st.hasMoreTokens()) {
    	        	String path = st.nextToken(",");
      	        if (!path.equals("")) fcl.addPath(path);
        	    }
          	  pathModel.setClassLoader(fcl);
            }

          // Compiler Option
          } else if (key.equals("Compile_ShowDebugMsg")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
							compilerModel.setDebugMode(b);
            }
          } else if (key.equals("Compile_Optimize")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setOptimizing(b);
            }
          } else if (key.equals("Compile_Warning")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setWarning(b);
            }
          } else if (key.equals("Compile_Verbose")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setVerboseMsg(b);
            }
          } else if (key.equals("Compile_Deprecation")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setDeprecation(b);
            }
          } else if (key.equals("Compile_Depend")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setDebugMode(b);
            }
          } else if (key.equals("Compile_NoWrite")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setNoWrite(b);
            }
          } else if (key.equals("Compile_Common")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setCommon(b);
            }
          } else if (key.equals("Compile_CommonOption")) {
          	if (st.hasMoreElements()) {
	          	String str = st.nextToken();
  	          compilerModel.setCommonOption(str);
            }
          } else if (key.equals("Compile_internalVM")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          compilerModel.setInternalVMMode(b);
            }
/*
          } else if (key.equals("Compile_gOption")) {
          	String str = st.nextToken("#");
            compilerModel.setDebugOption(str);
          } else if (key.equals("Compile_OptimizeOption")) {
          	String str = st.nextToken("#");
            compilerModel.setOptimizeOption(str);
          } else if (key.equals("Compile_WarningOption")) {
          	String str = st.nextToken("#");
            compilerModel.setWarningOption(str);
          } else if (key.equals("Compile_VerboseOption")) {
          	String str = st.nextToken("#");
            compilerModel.setVerboseOption(str);
          } else if (key.equals("Compile_DepreOption")) {
          	String str = st.nextToken("#");
            compilerModel.setDepreOption(str);
          } else if (key.equals("Compile_DependOption11")) {
          	String str = st.nextToken("#");
            compilerModel.setDependOption(str);
          } else if (key.equals("Compile_DependOption12")) {
          	String str = st.nextToken("#");
            compilerModel.setDebugOption(str);
          } else if (key.equals("Compile_NoWriteOption11")) {
          	String str = st.nextToken("#");
            compilerModel.setDebugOption(str);
          } else if (key.equals("Compile_CommonOption")) {
          	String str = st.nextToken("#");
            compilerModel.setDebugOption(str);
*/
					// Interpreter Option
          } else if (key.equals("Interpreter_Verbose")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setVerboseMode(b);
            }
          } else if (key.equals("Interpreter_Debug")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setDebugMode(b);
            }
          } else if (key.equals("Interpreter_NoAsyncGC")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setNoAsyncGCMode(b);
            }
          } else if (key.equals("Interpreter_VerboseGC")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setVerboseGCMode(b);
            }
          } else if (key.equals("Interpreter_NoClassGC")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setNoClassGCMode(b);
            }
          } else if (key.equals("Interpreter_MaxNatStack")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setMaxNatStackMode(b);
            }
          } else if (key.equals("Interpreter_MaxNatStackSize")) {
          	if (st.hasMoreElements()) {
	          	String str = st.nextToken();
  	          interpreterModel.setMaxNatStackSize(str);
            }
          } else if (key.equals("Interpreter_MaxJavaStack")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setMaxJavaStackMode(b);
            }
          } else if (key.equals("Interpreter_MaxJavaStackSize")) {
          	if (st.hasMoreElements()) {
	          	String str = st.nextToken();
  	          interpreterModel.setMaxJavaStackSize(str);
            }
          } else if (key.equals("Interpreter_InitHeap")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setInitHeapMode(b);
            }
          } else if (key.equals("Interpreter_InitHeapSize")) {
          	if (st.hasMoreElements()) {
	          	String str = st.nextToken();
			        interpreterModel.setInitHeapSize(str);
            }
          } else if (key.equals("Interpreter_MaxHeap")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setMaxHeapMode(b);
            }
          } else if (key.equals("Interpreter_MaxHeapSize")) {
          	if (st.hasMoreElements()) {
	          	String str = st.nextToken();
  	          interpreterModel.setMaxHeapSize(str);
          	}
          } else if (key.equals("Interpreter_Common")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setCommonMode(b);
            }
          } else if (key.equals("Interpreter_CommonOption")) {
          	if (st.hasMoreElements()) {
	          	String str = st.nextToken();
  	          interpreterModel.setCommonOption(str);
            }
          } else if (key.equals("Interpreter_MainClass")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
  	          interpreterModel.setMainClassMode(b);
            }
          } else if (key.equals("Interpreter_MainClassName")) {
          	if (st.hasMoreElements()) {
	          	String str = st.nextToken();
  	          interpreterModel.setMainClassName(str);
            }
          } else if (key.equals("Interpreter_InternalVM")) {
          	if (st.hasMoreElements()) {
	          	boolean b = Boolean.valueOf(st.nextToken()).booleanValue();
	            interpreterModel.setInternalVMMode(b);
            }
          }
        }
        pathModel.setAllLibInfoContainer(alic);
        pathModel.setSelectedLibInfoContainer(slic);
        pathModel.setJdkInfoContainer(ajic);

        prj.setTreeModel(treeModel);
        prj.setPathModel(pathModel);
        prj.setCompilerModel(compilerModel);
        prj.setInterpreterModel(interpreterModel);
        prj.isModified = false;
/*
				ObjectInputStream in = new ObjectInputStream(	new FileInputStream(projFile));
				Object obj = in.readObject();
				if (obj instanceof Project) {
					prj = (Project)obj;
          prj.setPath(projFile.getAbsolutePath());
          prj.initLibraryPool();
          prj.syncEntrysWithRealFile();

          projects.addElement(prj);
				}
				in.close();
*/
			} catch (IOException e) {
			}
		}
		return prj;
  }

	/**
	 *  해당 프로젝트 저장
	 *
	 *  @param prj 프로젝트 객체
	 */
	static public void saveProject(Project prj) {
		if (prj != null) {
			prj.isModified = false;
      prj.setLastSavedTime();

			try {
	      PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
        										new FileOutputStream(new File(prj.getPath())))));
				out.print(prj.toString());
        out.flush();
        out.close();
      /*
				ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(
																				new File(prj.getPath())));
				if (out != null) {
					out.writeObject(prj);
					out.flush();
				}
				out.close();
      */
			} catch (IOException e) {
      	e.printStackTrace();
			}
		}
	}

	/**
	 *  프로젝트가 열려있는지 본다.
	 */
  static public Project findProject(String prjName) {
    for (int i = 0; i < projects.size(); i++) {
      Project prj = (Project)projects.elementAt(i);
      if (prj.getProjectName().equals(prjName)) {
        return prj;
      }
    }

    return null;
  }

  /**
   *  프로젝트를 삭제한다.
   */
  static public void removeProject(String prjName) {
    for (int i = 0; i < projects.size(); i++) {
      Project prj = (Project)projects.elementAt(i);
      if (prj.getProjectName().equals(prjName)) {
        projects.removeElementAt(i);
        System.gc();
        break;
      }
    }
	}

	/**
	 *  현재 활성화된 프로젝트를 나타낸다.
	 *
	 *  @param current 현재 활성화된 프로젝트 객체
	 */
	static public void setCurrentProject(Project prj) {
		current = prj;
	}

	/**
	 *  현재 활성화된 프로젝트를 얻어온다.
	 *
	 *  @return Project 현재 활성화된 프로젝트 객체
	 */
	static public Project getCurrentProject() {
		return current;
	}

  /**
   *  열었던 모든 프로젝트를 얻어온다.
   */
  static public Vector getProjects() {
  	return projects;
  }

	/**
	 *  저장되지 않은 프로젝트가 있는지 본다.
	 */
  static public void canClose() {
    for (int i = 0; i < projects.size(); i++) {
      Project prj = (Project)projects.elementAt(i);
      if (prj.isModified()) {
				try {
					ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(
																					new File(prj.getPath(), prj.getProjectName())));
					if (out != null) {
						out.writeObject(prj);
						out.flush();
					}
					out.close();
				} catch (IOException e) {
				}
				//prj.saveProject();
			}
    }
  }
}
