/*
 * $Header: /AntIDE/source/ant/codecontext/CodeContext.java 91    99-06-02 4:51p Kahn $
 * Ant ( JDK wrapper Java IDE )
 * Version 1.0
 * Copyright (c) 1998-1999 Antsoft Co. All rights reserved.
 *  This program and source file is protected by Korea and international
 * Copyright laws.
 *
 * $Revision: 91 $
 * Part : Code Context Module
 * Author: Kim, Sung-hoon(kahn@antj.com)
 * Starting at 1999. 1. 20.
 *                   2.  1.
 *                   2.  2.
 *                   2.  3.
 *                   2.  4.
 *                   2.  5.
 *                   2.  6.
 *                   2.  7.
 *                   2.  8.
 *                   2.  9.
 *                   2. 10.
 *                   2. 11.
 *                   3. 10.
 */

package com.antsoft.ant.codecontext;

import com.antsoft.ant.codecontext.codeeditor.*;
import com.antsoft.ant.manager.projectmanager.*;
import com.antsoft.ant.pool.sourcepool.*;
import com.antsoft.ant.pool.librarypool.*;
import com.antsoft.ant.pool.packagepool.*;
import com.antsoft.ant.pool.classpool.*;
import com.antsoft.ant.main.*;
import com.antsoft.ant.util.*;
import com.antsoft.ant.browser.packagebrowser.*;
import com.antsoft.ant.property.JdkInfo;

//import ant.codecontext.parser.*;

import java.io.*;
import java.util.*;
import javax.swing.text.*;
import javax.swing.event.*;

/**
  The module Code Context.

  @author Kim, sung-hoon.
  */
public class CodeContext {
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Class Member Field Declaration..............

	protected Hashtable totaltabSymbol;  // has table of project symbol table.
	protected Hashtable totaltabImport;  // has table of project import table.

  // the symbol table(it has field & method member.)
  protected Hashtable symtab;		// currently used symbol table.
  protected Hashtable symtabs;	// symbol table list of all opened file(in project).

  // the import list is stored this field.
  protected Hashtable imptab;		// currently used import table.
  protected Hashtable imptabs;	// import table list of all opened file(in project).

  protected Hashtable classtableall = new Hashtable();
  protected Hashtable classtable = null;

	protected String currentPrj="Files";

	protected static Daemon daemon=null;

	protected SourcePool sourcePool=null;  // SourcePool reference
	protected ProjectExplorer projectExplorer;  // ProjectExplorer reference

	// for Conversation to the CodeEditor(that is, ProjectExplorer).
	protected static SourceEntry se;
	protected static JavaDocument currentDocument;		// current JavaDocument reference.
	protected DocListener docListener;			// current listener reference.

	// current package name of the currently activated source code.
	protected String nameOfPackage="dummypack";

  protected Hashtable openedProject = new Hashtable();
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Constructor......................

	/**
	  Constructor.
    */
	public CodeContext() {
   	totaltabSymbol=new Hashtable();
   	totaltabImport=new Hashtable();

    symtabs=new Hashtable();
    imptabs=new Hashtable();

		totaltabSymbol.put("Files",symtabs);
		totaltabImport.put("Files",imptabs);

    daemon=new Daemon(this);
    daemon.start();
 	}
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Project관련 public method declaration...........

	/**
	 * when opening project, the SymbolTable is read in specified table.
	 */
 	public void openPrj(String prj,String path) {
    openedProject.put(path,projectExplorer.getProject());
		File f=new File(path+".property.symbol");
		if (f.exists()) {
			try {
				FileInputStream istream=new FileInputStream(f);
				ObjectInputStream stream=new ObjectInputStream(istream);

        classtable=(Hashtable)stream.readObject();

				stream.close();
				istream.close();
			} catch (Exception e) {
				System.out.println("read Object "+e.toString());
			}
   		symtabs=new Hashtable();
		}
   	else {
      classtable=new Hashtable();
   	}

		totaltabSymbol.put(prj,symtabs);
		totaltabImport.put(prj,imptabs);
    classtableall.put(prj,classtable);
	}

	/**
	 * when tabbing project, the SymbolTable is read in specified table.
	 */
 public void movePrj(String prj) {
    classtable=(Hashtable)classtableall.get(prj);
    if (classtable==null) {
      classtable = new Hashtable();
      classtableall.put(prj,classtable);
    }

    symtabs=(Hashtable)totaltabSymbol.get(prj);
    imptabs=(Hashtable)totaltabImport.get(prj);
    if (symtabs==null) symtabs=new Hashtable();
    if (imptabs==null) imptabs=new Hashtable();

    containers=new ClassMemberContainerList();
	  Enumeration enum=symtabs.keys();
		while (enum!=null&&enum.hasMoreElements()) {
  	  String key=(String)enum.nextElement();
  		symtab=(Hashtable)symtabs.get(key);
 	  	imptab=(Hashtable)imptabs.get(key);

   		createClassMember();
   	}
  }

  /*
   * when adding files, this method is called, and it parse the files, then makes class table...
   */
  public void addFiles(Vector files) {
    for (int i=0;i<files.size();++i) {
      File f = new File((String)files.elementAt(i));
      DispatchClassInfo dispatch = new DispatchClassInfo(f);
      dispatch.makeClassInfo();
      Hashtable table = dispatch.getTable();
      String packname = dispatch.getPackageName();

      Enumeration e = table.keys();
      while (e!=null&&e.hasMoreElements()) {
        String key = packname+"."+(String)e.nextElement();
        classtable.put(key,(String)files.elementAt(i));
      }
    }
  }

	/**
	 * when closing project, the SymbolTable is saved in specified table.
	 */
	public void closePrj(String prj,String path) {
		if (prj.equals("Files")) {
			System.out.println("Files tab...");
			return;
		}

    classtableall.remove(prj);
	}

  public void exitProgram() {
    Enumeration e = openedProject.keys();
    while (e!=null&&e.hasMoreElements()) {
      String path = (String)e.nextElement();
      Project prj = (Project)openedProject.get(path);
      SymbolSave saver = new SymbolSave(path+".property.symbol",prj);
      saver.run();
    }
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // table maintenance method declaration..............

  /**
   get the symbol table reference.

   @return the symbol table as Hashtable reference.
   */
  public Hashtable getSymTab() {
    return symtab;
  }

  /**
   set the symbol table for Daemon Class.

   @param t modified symbol table as Hashtable.
   */
  public void setSymTab(Hashtable t) {
    symtab=t;

    Enumeration e = symtab.elements();
    while (e!=null&&e.hasMoreElements()) {
      SymbolTableEntry entry = (SymbolTableEntry)e.nextElement();
      if (entry.getSuperClass().lastIndexOf(".")==-1) {
        String sup = entry.getSuperClass();
        Enumeration enum=imptab.keys();
        boolean found = false;

        while (enum!=null&&enum.hasMoreElements()) {  // in jdk.
          String impString=(String)enum.nextElement();
          if (impString.equals(nameOfPackage)) continue;
          String fullClassName=null;
          int pos=impString.lastIndexOf("*");
          if (pos!=-1) fullClassName=impString.substring(0,pos)+sup;
          else {
            int lastDot=impString.lastIndexOf(".");
            if (!sup.equals(impString.substring(lastDot+1,impString.length()))) continue;
            fullClassName=impString;
          }
          if (ClassPool.exist(fullClassName)) {
            entry.setSuperClass(fullClassName);
            found = true;
            break;
          }
          if (classtable.containsKey(nameOfPackage+"."+sup)) {
            entry.setSuperClass(nameOfPackage+"."+sup);
            found = true;
            break;
          }
        }

        if (!found)
          if (ClassPool.exist("java.lang."+sup)) entry.setSuperClass("java.lang."+sup);
      }
    }
  }

  // get table of symbol table.
  public Hashtable getSymTabs() {
    return symtabs;
  }

  /**
   get the import table reference.

   @return the import table as Hashtable reference.
   */
  public Hashtable getImpTab() {
    return imptab;
  }
  // set the import table for Daemon Class.
  public void setImpTab(Hashtable t) {
    imptab=t;
  }

  public Hashtable getClassTable() {
    return classtable;
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // various reference of the object................

	public static final ClassPool classPool = new ClassPool();	// Class Pool reference.
	public static final LibraryPool libraryPool = new LibraryPool();	// Library Pool reference.
	public static final PackagePool packagePool = new PackagePool();	// Package Pool reference.
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// for Listener Collection of some event conversation.
	private static Vector sourceBrowserEventListener=new Vector();	// Source Browser Event Listener collection
	private Vector editFunctionEventListener=new Vector();	// Edit Function Event Listener collection

	public static JavaDocument getCurrentDocument() {
		return currentDocument;
	}

  /**
    get the Edit Function Event Listener list.

    @return Vector.
    */
  public Vector getEditFunctionEventListener() {
    return editFunctionEventListener;
  }

  /**
    get the Source Browser Event Listener list.

    @return Vector.
    */
  public static Vector getSourceBrowserEventListener() {
    return sourceBrowserEventListener;
  }

	// class member container list for search class of current project.
	static ClassMemberContainerList containers=new ClassMemberContainerList();

  /**
    getting the Class Member Container List reference.

    @return class member container list.
    */
  public static ClassMemberContainerList getClassMemberContainerList() {
    return containers;
  }

  /**
    getting the name of this package.

    @return the name of package as String.
    */
  public String getNameOfPackage() {
    return nameOfPackage;
  }

	/**
	  setting source Pool.

	  @param the ClassDesinger Ojbect reference.
	  */
	public void setSourcePool(SourcePool o) {
    sourcePool=o;
  }

	/**
	  setting ProjectExplorer reference.

	  @param the ProjectExplorer Ojbect reference.
	  */
	public void setProjectExplorer(ProjectExplorer o) {
    projectExplorer=o;
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  public void doParsing(File f) {
    TableCreatorFromFile creator = new TableCreatorFromFile(f);
    Hashtable oldsymtab = symtab;
    Hashtable oldimptab = imptab;

    symtab=creator.getSymbolTable();
    imptab=creator.getImportListTable();
    String packname = creator.getPackageName();
    createClassMember();

    Enumeration e = symtab.elements();
    while (e!=null&&e.hasMoreElements()) {
      SymbolTableEntry entry = (SymbolTableEntry)e.nextElement();
      if (entry.getSuperClass().lastIndexOf(".")==-1) {
        String sup = entry.getSuperClass();
        Enumeration enum=imptab.keys();
        boolean found = false;

        while (enum!=null&&enum.hasMoreElements()) {  // in jdk.
          String impString=(String)enum.nextElement();
          if (impString.equals(packname)) continue;
          String fullClassName=null;
          int pos=impString.lastIndexOf("*");
          if (pos!=-1) fullClassName=impString.substring(0,pos)+sup;
          else {
            int lastDot=impString.lastIndexOf(".");
            if (!sup.equals(impString.substring(lastDot+1,impString.length()))) continue;
            fullClassName=impString;
          }
          if (ClassPool.exist(fullClassName)) {
            entry.setSuperClass(fullClassName);
            found = true;
            break;
          }
          if (classtable.containsKey(packname+"."+sup)) {
            entry.setSuperClass(packname+"."+sup);
            found = true;
            break;
          }
        }

        if (!found)
          if (ClassPool.exist("java.lang."+sup)) entry.setSuperClass("java.lang."+sup);
      }
    }

    String name = f.getName();
    String key = f.getPath();
    key=key.substring(0,key.indexOf("\\"+name))+name;
    symtabs.put(key,symtab);
    imptabs.put(key,imptab);

    symtab=oldsymtab;
    imptab=oldimptab;
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // setting source and parse the file, and make event for source browser...........

	private void insertTable(String tableKey) {
		// 만약 기존에 없는 것이라면.... 새로이 생성한다.
    TableCreator tableCreator=new TableCreator(currentDocument);
    symtab=tableCreator.getSymbolTable();
    imptab=tableCreator.getImportListTable();

    if (tableCreator.hasMain()) {
      String pack = tableCreator.getPackageName();
      if (pack.equals("dummypack")) setRunnable(tableCreator.getMainClass());
      else setRunnable(pack+"."+tableCreator.getMainClass());
    }
    else { setRunnable(null); }

		// 새로 생성한 table을 table list에 put한다.
		symtabs.put(tableKey,symtab);
		imptabs.put(tableKey,imptab);

		createClassMember();
	}

	/**
	  setting current Source Entry reference.

	  @param the SourceEntry Ojbect reference including current document reference.
	  */
	public void setSourceEntry(SourceEntry sourceEntry) {
		se=sourceEntry;
		Daemon.setTableKey(se.getPath()+se.getName());
		nameOfPackage="dummypack";
		if (docListener!=null) {
			currentDocument.removeDocumentListener(docListener);
			//currentDocument.removeUndoableEitListener(docListener);
		}

		currentDocument=sourceEntry.getDocument();

		docListener=new DocListener();
    currentDocument.addDocumentListener(docListener);
    //currentDocument.addUndoableEditListener(docListener);

		// 기존에 존재하던 table을 가져온다.
		String tableKey=se.getPath()+se.getName();
		symtab=(Hashtable)symtabs.get(tableKey);

		if (symtab==null) insertTable(tableKey);
		// 기존에 있으면, import table도 가져온다.
		else {
      imptab=(Hashtable)imptabs.get(tableKey);
    }

		makeSourceBrowserEvent(false);

    Enumeration e = symtab.elements();
    while (e!=null&&e.hasMoreElements()) {
      SymbolTableEntry entry = (SymbolTableEntry)e.nextElement();
      if (entry.getSuperClass().lastIndexOf(".")==-1) {
        String sup = entry.getSuperClass();
        Enumeration enum=imptab.keys();
        boolean found = false;

        while (enum!=null&&enum.hasMoreElements()) {  // in jdk.
          String impString=(String)enum.nextElement();
          if (impString.equals(nameOfPackage)) continue;
          String fullClassName=null;
          int pos=impString.lastIndexOf("*");
          if (pos!=-1) fullClassName=impString.substring(0,pos)+sup;
          else {
            int lastDot=impString.lastIndexOf(".");
            if (!sup.equals(impString.substring(lastDot+1,impString.length()))) continue;
            fullClassName=impString;
          }
          if (ClassPool.exist(fullClassName)) {
            entry.setSuperClass(fullClassName);
            found = true;
            break;
          }
          if (classtable.containsKey(nameOfPackage+"."+sup)) {
            entry.setSuperClass(nameOfPackage+"."+sup);
            found = true;
            break;
          }
        }

        if (!found)
          if (ClassPool.exist("java.lang."+sup)) entry.setSuperClass("java.lang."+sup);
      }
    }
    //getDependency();
  }

	/**
	  setting current SourceEntry reference.

	  @param the SourceEntry Ojbect reference including current document reference.
	  */
	public void setReloadSourceEntry(SourceEntry sourceEntry) {
		se=sourceEntry;
		Daemon.setTableKey(se.getPath()+se.getName());
		nameOfPackage="dummypack";
		if (docListener!=null) {
			currentDocument.removeDocumentListener(docListener);
			//currentDocument.removeUndoableEitListener(docListener);
		}

		currentDocument=sourceEntry.getDocument();

		docListener=new DocListener();
    currentDocument.addDocumentListener(docListener);
    //currentDocument.addUndoableEditListener(docListener);

		String tableKey=se.getPath()+se.getName();

		insertTable(tableKey);
		makeSourceBrowserEvent(false);

    Enumeration e = symtab.elements();
    while (e!=null&&e.hasMoreElements()) {
      SymbolTableEntry entry = (SymbolTableEntry)e.nextElement();
      if (entry.getSuperClass().lastIndexOf(".")==-1) {
        String sup = entry.getSuperClass();
        Enumeration enum=imptab.keys();
        boolean found = false;

        while (enum!=null&&enum.hasMoreElements()) {  // in jdk.
          String impString=(String)enum.nextElement();
          if (impString.equals(nameOfPackage)) continue;
          String fullClassName=null;
          int pos=impString.lastIndexOf("*");
          if (pos!=-1) fullClassName=impString.substring(0,pos)+sup;
          else {
            int lastDot=impString.lastIndexOf(".");
            if (!sup.equals(impString.substring(lastDot+1,impString.length()))) continue;
            fullClassName=impString;
          }
          if (ClassPool.exist(fullClassName)) {
            entry.setSuperClass(fullClassName);
            found = true;
            break;
          }
          if (classtable.containsKey(nameOfPackage+"."+sup)) {
            entry.setSuperClass(nameOfPackage+"."+sup);
            found = true;
            break;
          }
        }

        if (!found)
          if (ClassPool.exist("java.lang."+sup)) entry.setSuperClass("java.lang."+sup);
      }
    }
  }

	private void makeSourceBrowserEvent(boolean flag) {
		// 현재 소스의 package name을 찾는다.
		Enumeration e=imptab.keys();
		while (e!=null&&e.hasMoreElements()) {
			String pstring=(String)e.nextElement();
			SymbolTableEntry ptable=(SymbolTableEntry)imptab.get(pstring);
			if (ptable.getMemberSort()==SymbolTableEntry.PACKAGE) {
				nameOfPackage=pstring;
				break;
			}
		}

		// SourceBrowser가 트리형식으로 내용을 보일수 있도록 event를 만든다.
    SourceBrowserEvent evt=new SourceBrowserEvent();
		// Symbol table을 iterate해서 event로 만들어 온다.
		SymbolTableIterator iter=new SymbolTableIterator(symtab);
		// depth가 member의 depth인 것까지 가져온다.
		Vector v=iter.iterateKey(SymbolTableIterator.MEMBER);
		evt.setEvents(v);

		// import table을 iterate해서 event로 만들어 온다.
		iter=new SymbolTableIterator(imptab);

		// import list에서는 모두 top의 depth만을 가진다.
		v=iter.iterateKey();
		evt.addEvents(v);		// other import lists.
		evt.alignment();  // alignment event as specified order.

		// 관련된 method를 invoke시켜준다.
 		for (int i=0;i<sourceBrowserEventListener.size();++i) {
      SourceBrowserEventListener l=(SourceBrowserEventListener)sourceBrowserEventListener.elementAt(i);
      if (flag) l.clearEvent();
    	if (evt!=null) l.insertEvent(evt);
		}

    Daemon.setLatestEvent(evt);
	}

	/**
	  modify this symbol table and import list table when the user commits the save file.
	  */
	public void modifyTableWhenSaveFile(boolean flag) {
		nameOfPackage="dummypack";
		String tableKey=se.getPath()+se.getName();

		Hashtable hashtable=(Hashtable)symtabs.get(tableKey);
		if (hashtable!=null) {
			symtabs.remove(tableKey);
			imptabs.remove(tableKey);
		}

		insertTable(tableKey);

		if (flag) makeSourceBrowserEvent(true);
	}
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // add listener of this object.

	/**
	  registering the Source Browser Event Listener Object.

	  @param l Source Browser Event Listener Object.
	  */
	public void addSourceBrowserEventListener(SourceBrowserEventListener l) {
		sourceBrowserEventListener.addElement(l);
	}

	/**
	  registering the Edit Function Event Listener Object.

	  @param l Edit Function Event Listener Object.
	  */
	public void addEditFunctionEventListener(EditFunctionEventListener l) {
		editFunctionEventListener.addElement(l);
	}
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // Document Listener............

  /**
    The inner class DocListener implements the Document interface,
    and when the DocumentEvent occurs, corresponding action is made.
    */
  class DocListener implements DocumentListener/*,UndoableEditListener*/ {
	  public void insertUpdate(DocumentEvent evt) {
			if (thread!=null) thread.setKeyPressed(true);

      try {
        int offset=evt.getOffset();        // 현재 삽입되는 곳의 offset을 구한다.

	      // offset이 속한 leaf element의 참조를 구한다.(currentDocument는
    	  // PlainDocument class를 extends했으므로 이 element는 leaf element이다.
			  Element elem=currentDocument.getParagraphElement(offset);

        // 이 element 내용들의 시작과 끝을 전체 Document에 상대적인 값으로 구한다.
        int startOffset=elem.getStartOffset();
   	    int endOffset=elem.getEndOffset();
       	int length=endOffset-startOffset;

        // 현재 변경되는 (추가되는) 곳의 한 라인의 내용을 가져온다.
        String str=currentDocument.getText(startOffset,length);

        int localOffset=offset-startOffset;

        // 여기서 catch() 앞까지가 ProjectExplorer와의 연동을 위한 event를 생성하는 곳이다.
        // 앞으로 수정을 해야 한다.
        char c=str.charAt(localOffset);

       	// Symbol Table Maintenance.
       	SymbolTableIterator stIterator=new SymbolTableIterator(symtab);
       	stIterator.modifyOffsetInTable(offset,evt.getLength());

				SymbolTableIterator stiter=new SymbolTableIterator(symtab);
				int curDepth=stiter.getDepth(offset);

        // For IntelliSense (named by Delphi)
        if (c=='.') {
         	if (curDepth<2) return;
         	if (!Main.property.isIntelliOn()) return;
					// intellisense에 대한 action을 취한다.
          dotOffset=offset;
					invokeThread(str.substring(0,localOffset),offset,1);
				}
        // For Parameterizing (named by Kim, Sung-Hoon)
        else if (c=='(') {
          openOffset=offset;
         	if (curDepth<2) return;
         	if (!Main.property.isIntelliOn()) return;
         	// parameterizing에 대한 action을 취한다.
					invokeThread(str.substring(0,localOffset),offset,2);
				}

         // 그외 SourceBrowser의 Tree형태의 그림을 위해
        else {
         	// line parsing을 이용하여 현재 입력중인 line을 parsing한다.
         	//if (c==' '||c=='\t'||c=='\n') return;
					Daemon.setTable(symtabs,imptabs);
					Daemon.setPackageName(nameOfPackage);
					Daemon.insertUpdateFlag=true;
					Daemon.setDepth(curDepth);
          daemon.interrupt();
        }
      } catch (BadLocationException e) {
        System.out.println("exception.... in the insertUpdate().");
      }
		}

		public void changedUpdate(DocumentEvent evt) {
		}

		public void removeUpdate(DocumentEvent evt) {
      try {
      	int offset=evt.getOffset();        // 현재 삽입되는 곳의 offset을 구한다.

       	// offset이 속한 leaf element의 참조를 구한다.(currentDocument는
       	// PlainDocument class를 extends했으므로 이 element는 leaf element이다.
				Element elem=currentDocument.getParagraphElement(offset);

        // 이 element 내용들의 시작과 끝을 전체 Document에 상대적인 값으로 구한다.
        int startOffset=elem.getStartOffset();
        int endOffset=elem.getEndOffset();
        int length=endOffset-startOffset;

        // 현재 변경되는 (추가되는) 곳의 한 라인의 내용을 가져온다.
        String str=currentDocument.getText(startOffset,length);

        // Symbol Table Maintenance.
        SymbolTableIterator stIterator=new SymbolTableIterator(symtab);
        stIterator.modifyOffsetInTable(offset,-evt.getLength());

				SymbolTableIterator stiter=new SymbolTableIterator(symtab);

				Daemon.setTable(symtabs,imptabs);
				Daemon.setPackageName(nameOfPackage);
				Daemon.insertUpdateFlag=true;
				Daemon.setDepth(stiter.getDepth(offset));
        daemon.interrupt();
      } catch (BadLocationException e) {
        System.out.println("exception.... in the removeUpdate().");
      }
		}

		/*
		public void undoableEditHappened(UndoableEditEvent evt) {
		}
		*/
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // creating class member information

	// class member container list creating method.
	void createClassMember() {
		if (symtabs.size()==0&&imptabs.size()==0) return;

		String currentPackage="dummypack";
		Enumeration e=imptab.keys();
		while (e!=null&&e.hasMoreElements()) {
			String key=(String)e.nextElement();

			SymbolTableEntry tab=(SymbolTableEntry)imptab.get(key);
			if (tab.getMemberSort()==SymbolTableEntry.PACKAGE) {
				// 현재의 package name을 구한다.
				currentPackage=key;
				break;
			}
		}

		// 최상위 symbol table의 key를 읽는다.
		Vector classes=new Vector();
		Enumeration en=symtab.keys();
		while (en!=null&&en.hasMoreElements()) {
			String key=(String)en.nextElement();
			classes.addElement(key);
		}

		// ClassMemberContainer와 ClassMember 객체를 선언하고서...
		ClassMemberContainer memberContainer;
		ClassMember member;

		// 각 class별로 member들을 search하여 class member container에 입력한다.
		for (int i=0;i<classes.size();++i) {
			memberContainer=new ClassMemberContainer();
			SymbolTableEntry tab=(SymbolTableEntry)symtab.get((String)classes.elementAt(i));

			// 하위 table이 있다면, 즉 member에 대한 table이 있다면.
			if (tab.table!=null) {
				SymbolTableIterator iter=new SymbolTableIterator(tab.table);
				Vector content=iter.iterateKey(SymbolTableIterator.TOP);

				// 모든 Member를 iterate하면서 ClassMember를 만들고,
				// 새로이 만든 객체를 ClassMemberContainer에 담는다.
				for (int j=0;j<content.size();++j) {
					// ClassMember들의 key string.

					String key=((EventContent)content.elementAt(j)).getContent();

					// SymbolTable에서 찾아서
                    Hashtable htab=tab.table;
					SymbolTableEntry t=(SymbolTableEntry)htab.get(key);

					// Field, inner class or interface, method들만을 취급한다.
					switch (t.getMemberSort()) {
						case SymbolTableEntry.FIELD:
							// ClassMember객체를 만들고 값을 assign하고
							member=new ClassMember();
							member.setName(key);
							member.setType(t.getType());
							member.setAccessType(t.getAccessType());
							member.setMemberType(ClassMember.FIELD);

							// ClassMemberContainer에 담는다.
							memberContainer.addContainer(member);
							break;

						case SymbolTableEntry.CLASS:
						case SymbolTableEntry.INTERFACE:
							// ClassMember객체를 만들고 값을 assign하고
							member=new ClassMember();
							member.setName(key);
							member.setType(t.getType());
							member.setAccessType(t.getAccessType());
							member.setMemberType(ClassMember.INNERCLASS);

							// ClassMemberContainer에 담는다.
							memberContainer.addContainer(member);
							break;

						case SymbolTableEntry.METHOD:
							// ClassMember객체를 만들고 값을 assign하고
							member=new ClassMember();

							// method의 경우는 parameter를 잘라서 써야하므로 tokenizing을 한다.
							StringTokenizer tokenizer=new StringTokenizer(key,"(,)",false);

							// 최초 token은 method name.
							if (tokenizer.hasMoreTokens()) member.setName(tokenizer.nextToken());
							while (tokenizer.hasMoreTokens()) {
								// 두번째부터 parameter type들이다.
								member.addParameterType(tokenizer.nextToken());
							}
              Vector temp = t.getParameters();
              if (temp!=null)
                for (int k=0;k<temp.size();++k) {
                  member.addParameter((String)temp.elementAt(k));
                }
							member.setType(t.getType());
							member.setAccessType(t.getAccessType());
							member.setMemberType(ClassMember.METHOD);

							// ClassMemberContainer에 담는다.
							memberContainer.addContainer(member);
							break;
					}
				}
			}

			// 최종적으로 패키지 이름과 class이름을 합친 string으로 key를 만들어
			String keyOfContainer=currentPackage+"."+classes.elementAt(i);

			// ClassMemberContainerList에 put한다.
			containers.putClassMemberList(keyOfContainer,memberContainer);
		}
	}
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // invoke thread for code insight...

	CodeInsight thread=null;

	private void invokeThread(String str,int offset,int what) {
		thread=new CodeInsight(str,offset,this,what);
		Thread intel=new Thread(thread);
    intel.setPriority(Thread.MAX_PRIORITY);
		intel.start();

		Runtime rt=Runtime.getRuntime();
		rt.gc();
	}
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  // additional function for shortcut and menu action.

	/**
	 * if F1 key is pressed on the class name,
	 * the context sensitive helper is activated, and web browser is running.
	 *
	 * @param offset the offset position.
	 */
	public void activateContextSensitiveHelp(int offset) {
		try {
			Element element=currentDocument.getParagraphElement(offset);

			// 이 element 내용들의 시작과 끝을 전체 Document에 상대적인 값으로 구한다.
			int startOffset=element.getStartOffset();
			int endOffset=element.getEndOffset();

			int length=endOffset-startOffset;
			int curchar=offset-startOffset;

			// 현재 변경되는 (추가되는) 곳의 한 라인의 내용을 가져온다.
			String str=currentDocument.getText(startOffset,length);

			LineTokenizer lineTokenizer=new LineTokenizer(str);

			while (lineTokenizer.getCurrentPosition()<curchar
						&&lineTokenizer.getCurrentPosition()<str.length())
                  lineTokenizer.nextToken();

			String thing=lineTokenizer.getTokenString();
      if (thing==null) return;

			SymbolTableIterator iterator=new SymbolTableIterator(symtab);
			String thingType=iterator.search(thing,offset);
      if (thingType==null) thingType=thing;

			CodeInsight thr=null;
			if (thingType!=null) thr=new CodeInsight(thingType,offset,this,3);
			else thr=new CodeInsight(thing,offset,this,3);
			Thread helper=new Thread(thr);
			helper.start();

			Runtime rt=Runtime.getRuntime();
			long wasFree=rt.freeMemory();
			long isFree;
			do {
				rt.gc();
				isFree=rt.freeMemory();
			} while (isFree<wasFree);
		} catch (BadLocationException e) {
			System.out.println(e.toString());
		}
	}

	/**
	  When Selection is occurred in Source Browser panel, moves the position for the caret
      to move.

	  @param str the member(field, method, import list, constructor...) to be selected.
	  */
	public void selectSourceBrowser(String cls,String str) {
    Hashtable table=null;
    if (cls!=null) {
      SymbolTableEntry ste=(SymbolTableEntry)symtab.get(cls);
      table=ste.table;
    }
    else table=symtab;

    // symbol table에서 먼저 찾아본다.
    SymbolTableIterator iter=new SymbolTableIterator(table);
    int offset=iter.search(str);
    if (offset!=-1) {
     	// project explorer의 caret위치를 수정하여 알려준다.
      if (offset>=currentDocument.getLength()) return;
     	projectExplorer.moveCaret(offset);
     	return;
    }

    // import list search....
		if (str.equals(nameOfPackage)) {
      SymbolTableIterator sIterator=new SymbolTableIterator(imptab);
      offset=sIterator.search(str);
      if (offset!=-1) {
        if (offset>=currentDocument.getLength()) return;
        projectExplorer.moveCaret(offset);
      }
      return;
    }

		if (str.indexOf(".*")!=-1) {

      PackageBrowser pckBrowser = new PackageBrowser(null,"Package Browser",false);
			String packstr=str.substring(0,str.indexOf(".*"));
			if (pckBrowser.showPackage(packstr)) {
        pckBrowser.setVisible(true);
        return;
      }
		}
		else {
			if (extractSource(str)) return;
		}

    SymbolTableIterator sIterator=new SymbolTableIterator(imptab);
    offset=sIterator.search(str);
    if (offset!=-1) {
      if (offset>=currentDocument.getLength()) return;
      projectExplorer.moveCaret(offset);
    }
	}

	private boolean extractSource(String str) {
		String temp=str;
    JdkInfo jdkInfo=ProjectManager.getCurrentProject().getPathModel().getCurrentJdkInfo(); // for null check
    if (jdkInfo==null) return false;
    String srcRootDir=jdkInfo.getSourcePath();

		JavaDocument docu=new JavaDocument();
		if (srcRootDir!=null && !srcRootDir.equals("")) {
			File f=new File(srcRootDir);

			if (f.isDirectory()) {		// source가 jar(압축)이 아닐때....
				// 화일을 찾아서 직접 document로 만들어 open한다.
				temp=temp.replace('.',File.separatorChar);

				// 각각이 file로 저장되어 있다.
				String fullFilePath=srcRootDir+File.separator+temp+".java";
				File srcFile=new File(fullFilePath);
				if (!srcFile.exists()) return false;	// check that the file exists actually.

				try {
					Reader in=new BufferedReader(new InputStreamReader(new FileInputStream(srcFile)));
   				char[] buff = new char[4096];
   				int nch;
   				while ((nch = in.read(buff, 0, buff.length)) != -1) {
   					docu.insertString(docu.getLength(), new String(buff, 0, nch), null);
         	}
   			} catch (IOException e) {
          e.printStackTrace();
    			return false;
   			} catch (BadLocationException e) {
          e.printStackTrace();
   				return false;
   			}
				// document를 진우에게 넘겨서 처리하도록 한다.
			}
			else {
				// 보통 src.jar의 entry들은 src/java/io/File.java로 압축되어있다.
				temp=temp.replace('.','/');

				String srcContent=SrcFileExtractor.extract(f,"src/"+temp+".java");
				if (srcContent==null) return false;

				try {
					docu.insertString(docu.getLength(),srcContent,null);
				} catch (BadLocationException be) {
          be.printStackTrace();
   				return false;
				}
			}
		}
		else {
			String result=SrcFileExtractor.extract(temp);
			if (result==null) return false;

      try{
  		  docu.insertString(docu.getLength(),result,null);
      }catch(BadLocationException be) {
        be.printStackTrace();
      	return false;
  	  }
  	}

		MainFrame.showLibSource(docu,str);
    return true;
	}

	/**
	 * if F2 key is pressed on the class name or vairable, the source viewer is activated.
	 *
	 * @param offset the offset position.
	 */
	public void viewJdkSource(int offset) {
    String thingType=getFullClassNameAtCursor(offset);
    if (thingType==null) return;
		extractSource(thingType);
	}

	/**
	 * get full class name at cursor position.
	 *
	 * @param offset the offset position.
	 */
	public String getFullClassNameAtCursor(int offset) {
		try {
			Element element=currentDocument.getParagraphElement(offset);

			// 이 element 내용들의 시작과 끝을 전체 Document에 상대적인 값으로 구한다.
			int startOffset=element.getStartOffset();
			int endOffset=element.getEndOffset();

			int length=endOffset-startOffset;
			int curchar=offset-startOffset;

			// 현재 변경되는 (추가되는) 곳의 한 라인의 내용을 가져온다.
			String str=currentDocument.getText(startOffset,length);

			LineTokenizer lineTokenizer=new LineTokenizer(str);

			while (lineTokenizer.getCurrentPosition()<curchar
						&&lineTokenizer.getCurrentPosition()<str.length())
				 lineTokenizer.nextToken();
			String thing=lineTokenizer.getTokenString();
      if (thing==null) return null;

			SymbolTableIterator iterator=new SymbolTableIterator(symtab);
			String classType=iterator.search(thing,offset);
			if (classType==null) classType=thing;

			String thingType=searchSourceFullClassName(classType);
			if (thingType!=null) return thingType;
		} catch (BadLocationException e) {
			System.out.println(e.toString());
		}
		return null;
  }

	// jdkSourceViewer에서 이용되는 method. - source 에 대한 full class name을 search한다.
	private String searchSourceFullClassName(String type) {
		Enumeration enum=imptab.keys();
		while (enum!=null&&enum.hasMoreElements()) {
			String impString=(String)enum.nextElement();

			if (impString.equals(nameOfPackage)) continue;

      String fullClassName=null;
      int pos=impString.lastIndexOf("*");
      if (pos!=-1) fullClassName=impString.substring(0,pos)+type;
      else {
			  int lastDot=impString.lastIndexOf(".");
				if (!type.equals(impString.substring(lastDot+1,impString.length()))) continue;
        fullClassName=impString;
			}

      if (ClassPool.exist(fullClassName)) return fullClassName;
		}

    if (ClassPool.exist("java.lang."+type)) return "java.lang."+type;

		return null;
	}

	/**
	 * When indentation button is clicked, the indentation is activated,
	 * and the document object is replaced
	 * with the indented document.
	 */
	public void indentDocument() {
		try {
			//String src=currentDocument.getText(0,currentDocument.getLength());
      JavaDocument docu=(JavaDocument)se.getDocument();
      String src=docu.getText(0,docu.getLength());

			JSBeautifier beautifier=new JSBeautifier();

			// Beautifier config setup
			boolean isTab=Main.property.isTab();
			if (isTab) beautifier.setTabIndentation();
			else beautifier.setSpaceIndentation(Main.property.getTabSpaceSize());

			beautifier.setMaxInStatementIndetation(40);
			if (!Main.property.isSwitchIndent()) beautifier.setSwitchIndent(false);
			if (Main.property.isCloseIndent()) beautifier.setBracketIndent(true);

			// Beautifier actioned.
			JavaDocument doc=beautifier.indentation(src);	// second parameter is code style...

			// change the document.
			se.setDocument(doc);
      projectExplorer.notifyChangeDocument();
      setSourceEntry(se);
		} catch (BadLocationException e) {
			System.out.println(e.toString());
		}
	}

	protected void setRunnable(String name) {
		se.setRunnableClassName(name);
	}

	protected void finalize() throws Throwable {
		daemon=null;
	}

 	private static int dotOffset=0;
  private static int openOffset=0;

 	public static int getDotOffset() {
   	return dotOffset;
 	}
  public static int getOpenOffset(){
    return openOffset;
  }

	public void thisCodeInsight(int offset) {
    dotOffset=offset-1;
		invokeThread(null,offset,1);
	}

  public int getInsertPosition(String name) {
    SymbolTableEntry entry=(SymbolTableEntry)symtab.get(name);
    if (entry.getRealEnd()) {
      int offset=entry.getEndOffset();
 			Element elem = currentDocument.getParagraphElement(offset);
      return elem.getStartOffset();
    }
    else return entry.getEndOffset();
  }

  public String getShortTypeOfField(String cls,String field) {
    SymbolTableEntry entry=(SymbolTableEntry)symtab.get(cls);
    if (entry==null) return null;
    SymbolTableEntry fieldEntry=(SymbolTableEntry)entry.table.get(field);
    if (fieldEntry==null) return null;
    return fieldEntry.getType();
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}
