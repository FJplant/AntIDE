/*
 * $Header: /AntIDE/source/ant/codecontext/SymbolTableIterator.java 11    99-06-01 12:44p Kahn $
 * Ant ( JDK wrapper Java IDE )
 * Version 1.0
 * Copyright (c) 1998-1999 Antsoft Co. All rights reserved.
 *  This program and source file is protected by Korea and international
 * Copyright laws.
 *
 * $Revision: 11 $
 * Part : Symbol Table Iterator Class
 * Copyright (c) 1998,1999 Ant Company, all right reserved.
 * Author: Kim, Sung-hoon(kahn@antj.com)
 * Starting at 1999. 2. 9.
 */

package com.antsoft.ant.codecontext;

import java.util.*;
import com.antsoft.ant.codecontext.codeeditor.*;

/**
  @author Kim, Sung-Hoon.
  */
public class SymbolTableIterator {
	private Hashtable table=null;
	public static final int TOP=0;
	public static final int MEMBER=1;
	public static final int ALL=2;

	/**
	  Constructor.

	  @param table the table to be iterated.
	  */
	public SymbolTableIterator(Hashtable table) {
		// iterate할 table을 설정한다.
		this.table=table;
	}

	/**
	  the Iteration method that iterates to specified depth in the import table
	  */
	public Vector iterateKey() {
		Enumeration enum=table.keys();

		Vector output=new Vector();

		while (enum!=null&&enum.hasMoreElements()) {
			String keyValue=(String)enum.nextElement();
			SymbolTableEntry nextOne=(SymbolTableEntry)table.get(keyValue);

			EventContent content=new EventContent();
			content.setContent(keyValue);
			switch (nextOne.getMemberSort()) {
				case SymbolTableEntry.IMPORT :
					content.setContentType(EventContent.IMPORT);
					break;
				case SymbolTableEntry.PACKAGE :
					content.setContentType(EventContent.PACKAGE);
					break;
			}

			output.addElement(content);
		}

		return output;
	}


	/**
	  the Iteration method that iterates to specified depth in the symbol table
	  except import list.

	  @param d the specified depth as int.
	  */
	public Vector iterateKey(int d) {
		if (d<0) return null;

		// return 할 vector object.
		Vector output=new Vector();

		Enumeration e=table.keys();
		if (e!=null) {
			while (e.hasMoreElements()) {
				// key를 받아서
				String keyValue=(String)e.nextElement();
				// table에서 꺼내고...
				SymbolTableEntry nextOne=(SymbolTableEntry)table.get(keyValue);

				// EventContent object를 만들고 나서
				EventContent content=new EventContent();
				// EventContent의 Content를 setting하고
				content.setContent(keyValue);

				// member의 종류에 따라서 ContentType을 setting한다.
				switch (nextOne.getMemberSort()) {
					case SymbolTableEntry.FIELD:
						content.setContentType(EventContent.ATTR);
						break;

					case SymbolTableEntry.METHOD:
					case SymbolTableEntry.CONSTRUCTOR:
						content.setContentType(EventContent.OPER);
						break;

					case SymbolTableEntry.CLASS:
						if (nextOne.getDepth()==0) content.setContentType(EventContent.CLASS);
						else content.setContentType(EventContent.INNER);
						break;
					case SymbolTableEntry.INTERFACE:
						if (nextOne.getDepth()==0) content.setContentType(EventContent.INTERFACE);
						else content.setContentType(EventContent.INNER);
						break;
          case SymbolTableEntry.OTHERS: continue;
				}

				// return할 Vector Object인 output 에 element를 add하고
				output.addElement(content);

				// 현재의 symbol table content의 또 다른 table을 포함한다면
				// recursive하게 그것 또한 iterate한다.
				if (nextOne.table!=null) {
					SymbolTableIterator iter=new SymbolTableIterator(nextOne.table);
					Vector temp=iter.iterateKey(d-1);

					if (temp!=null) for (int i=0;i<temp.size();++i) output.addElement(temp.elementAt(i));
				}
			}
		}
		return output;
	}

	/**
	  search for specified token with absolute offset and return its result type.

	  @param symbol the symbol string to search for.
	  @param offset the symbol's start offset from the beginning of the current document.
	  */
	public String search(String symbol, int offset) {
		// 현재의 hash table(symbol table)에서 symbol을 찾아보고
		SymbolTableEntry elem=(SymbolTableEntry)table.get(symbol);

		// 있으면 그것의 type을 return한다.
		if (elem!=null) return elem.getType();

		// 없으면....
		Enumeration enumerator=table.elements();
		while (enumerator!=null&&enumerator.hasMoreElements()) {
			// 그 아래 포함된 table들을 검색한다.
			elem=(SymbolTableEntry)enumerator.nextElement();
			if (elem.table==null) continue;		// 하위 table이 존재하지 않는다.
												// 즉, field나 variable 선언이고 block이 아니다.

			if (elem.getStartOffset()>offset) continue;	// 현재의 offset이 포함되지 않는 block
			if (elem.getEndOffset()<offset) continue;	// 현재의 offset이 포함되지 않는 block

			SymbolTableIterator iter=new SymbolTableIterator(elem.table);
			return iter.search(symbol,offset);
		}

		return null;
	}

	/**
	  search the offset in the document of the specified String.
      if not found, then return -1.

	  @param symbol specified string
	  @return the start offset in the document.
	  */
	public int search(String symbol) {
		// 현재의 hash table(symbol table)에서 symbol을 찾아보고
		SymbolTableEntry elem=(SymbolTableEntry)table.get(symbol);

		// 있으면 그것의 type을 return한다.
		if (elem!=null) return elem.getStartOffset();

		// 없으면....
		Enumeration enumerator=table.elements();
		while (enumerator!=null&&enumerator.hasMoreElements()) {
			// 그 아래 포함된 table들을 검색한다.
			elem=(SymbolTableEntry)enumerator.nextElement();
			if (elem.table==null) continue;		// 하위 table이 존재하지 않는다.
												// 즉, field나 variable 선언이고 block이 아니다.

			SymbolTableIterator iter=new SymbolTableIterator(elem.table);
			int retValue=iter.search(symbol);
			if (retValue!=-1) return retValue;
		}

		return -1;
	}

	/**
	  iterate the symbol table(hashtable of the tree structure) and modifies the offset of starting
	  and ending with specified length.

	  @param offset specified offset to be standard.
	  @param length specified length to be modified.
	  				if (length>0), it must be inserting.
	  				if (length<0), it must be removing.
	  */
	public void modifyOffsetInTable(int offset,int length) {
		Enumeration e=table.elements();

		while (e!=null&&e.hasMoreElements()) {
			SymbolTableEntry object=(SymbolTableEntry)e.nextElement();
			int sos=object.getStartOffset();	// start offset.
			int eos=object.getEndOffset();		// end offset.

			if (sos>=offset) {
				object.setStartOffset(sos+length);
				object.setEndOffset(eos+length);

				if (object.table!=null) {
					SymbolTableIterator stIterator=new SymbolTableIterator(object.table);
					stIterator.modifyOffsetInTable(offset,length);
				}
			}
			else if (eos>offset) {
				object.setEndOffset(eos+length);

				if (object.table!=null) {
					SymbolTableIterator stIterator=new SymbolTableIterator(object.table);
					stIterator.modifyOffsetInTable(offset,length);
				}
			}
		}
	}

	/**
	  search the all overloading method.

	  @param str the specified method name without paramater type style.
	  @param offset the offset that the str is appeared.
	  @return the method parameter list as the Vector value.
	  */
	public Vector searchAllOverloadedMethod(String str,int offset) {
		Enumeration e=table.keys();

		SymbolTableEntry wanted=null;
		while (e!=null&&e.hasMoreElements()) {
			String s=(String)e.nextElement();
			SymbolTableEntry elem=(SymbolTableEntry)table.get(s);
			if (elem.getEndOffset()>offset) {
				wanted=elem;
				break;
			}
		} // end of while.

		if (wanted==null) return null;

		Hashtable tab=null;
		if (wanted.table!=null) tab=wanted.table;
		else return null;

   	Vector eventString=null;
   	Enumeration en=tab.keys();
		while (en!=null&&en.hasMoreElements()) {
     	String string=(String)en.nextElement();
			if (string.indexOf("(")==-1) continue;
     	String comp=string.substring(0,string.indexOf("("));
     	if (!comp.equals(str)) continue;

			if (eventString==null) eventString=new Vector();

      SymbolTableEntry entry = (SymbolTableEntry)tab.get(string);
      Vector temp = entry.getParameters();
     	if (temp==null)	eventString.addElement("<no parameter>");
			else {
        StringBuffer buf = new StringBuffer();
        for (int i=0;i<temp.size();++i) buf.append(temp.elementAt(i)+",");
        eventString.addElement(buf.toString().substring(0,buf.length()-1));
      }
		}

   	return eventString;
 	}

  	/**
      get the depth of the specified offset.

	  @param offset the offset.
      @return the depth as the int value.
      */
  	public int getDepth(int offset) {
  		Enumeration e=table.keys();
  		while (e!=null&&e.hasMoreElements()) {
        String key=(String)e.nextElement();
  			SymbolTableEntry elem=(SymbolTableEntry)table.get(key);
  			if (elem.getStartOffset()<=offset&&elem.getEndOffset()>=offset) {
  				if (elem.table!=null) {
  					SymbolTableIterator iter=new SymbolTableIterator(elem.table);
  					return iter.getDepth(offset)+1;
  				}

  				return 1;
  			}
  		}

  		return 0;
  	}

	/**
	  get the class name corresponding with "this" token.

	  @param offset the offset.
	  @return the class name as String value.
	  */
	public String getThisClassName(int offset) {
		Enumeration e=table.keys();
		while (e!=null&&e.hasMoreElements()) {
			String str=(String)e.nextElement();

			SymbolTableEntry element=(SymbolTableEntry)table.get(str);
			if (element.getStartOffset()<=offset&&element.getEndOffset()>=offset) return str;
		}

		return null;
	}

 	public Vector getLocalVarEvent(int offset) {
    Vector localVar=new Vector();

		Enumeration e=table.keys();
		while (e!=null&&e.hasMoreElements()) {
      String name=(String)e.nextElement();
			SymbolTableEntry object=(SymbolTableEntry)table.get(name);
      int depth=object.getDepth();

      if (depth<2) {
         if (object.table!=null) {
           if (object.getStartOffset()>=offset||object.getEndOffset()<offset) continue;
 					 SymbolTableIterator stIterator=new SymbolTableIterator(object.table);
					 Vector temp=stIterator.getLocalVarEvent(offset);
           for (int i=0;i<temp.size();++i) localVar.addElement(temp.elementAt(i));
         }
         continue;
      }

		  int sos=object.getStartOffset();	// start offset.
 			if (sos>=offset) continue;

      if (object.table!=null) {
    	  int eos=object.getEndOffset();		// end offset.
    		if (eos<offset) continue;
 			  SymbolTableIterator stIterator=new SymbolTableIterator(object.table);
				Vector temp=stIterator.getLocalVarEvent(offset);
        for (int i=0;i<temp.size();++i) localVar.addElement(temp.elementAt(i));
        continue;
      }

      if (object.getMemberSort()==SymbolTableEntry.FIELD) {
         if (sos<offset) localVar.addElement(name+":Local:"+object.getType());
      }
		}

    return localVar;
	}

  /*
  public Hashtable getDependentClasses() {
    Hashtable result = null;

    Enumeration e = table.keys();
    while (e!=null&&e.hasMoreElements()) {
      String symbol = (String)e.nextElement();
      SymbolTableEntry entry = (SymbolTableEntry)table.get(symbol);
      String type = entry.getType();
      if (type != null) {
        if (type.equals("int")||type.equals("byte")||type.equals("char")||type.equals("boolean")||type.equals("void")||
            type.equals("long")||type.equals("float")||type.equals("double")||type.equals("String")||type.equals("Object"));
        else {
          if (result == null) result = new Hashtable();
          if (type.indexOf("[")!=-1) type = type.substring(0,type.indexOf("["));
          //System.out.println("the type = "+type);
          result.put(type,"");
        }
      }

      if (entry.getMemberSort()==SymbolTableEntry.CLASS||entry.getMemberSort()==SymbolTableEntry.INTERFACE) {
        if (entry.getSuperClass()!=null) {
          if (result==null) result = new Hashtable();
          result.put(entry.getSuperClass(),"");
        }
        Vector implementsInterfaces = entry.getImplementsInterfaces();
        if (implementsInterfaces!=null) {
          if (result == null) result = new Hashtable();
          for (int i=0;i<implementsInterfaces.size();++i) result.put(implementsInterfaces.elementAt(i),"");
        }
      }

      if (entry.table!=null) {
        SymbolTableIterator iterator = new SymbolTableIterator(entry.table);
        //SymbolTableIterator.depth++;
        Hashtable temp = iterator.getDependentClasses();
        if (temp!=null) {
          Enumeration keys = temp.keys();
          while (keys!=null&&keys.hasMoreElements()) {
            String key = (String)keys.nextElement();
            if (result==null) result = new Hashtable();
            result.put(key,"");
          }
        }
      }
    }
    //SymbolTableIterator.depth--;
    return result;
  }
  */
}

